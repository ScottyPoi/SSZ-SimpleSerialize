"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6050],{8219:function(e,t){function r(e,t){const r=BigInt(1)<<BigInt(e);if(t>=r)throw new Error("index too large for depth");return r|t}Object.defineProperty(t,"__esModule",{value:!0}),t.gindexChild=t.gindexParent=t.gindexSibling=t.concatGindices=t.getGindexBits=t.gindexIterator=t.getGindicesAtDepth=t.iterateAtDepth=t.countToDepth=t.convertGindexToBitstring=t.toGindexBitstring=t.toGindex=t.bitIndexBigInt=void 0,t.bitIndexBigInt=function(e){return e.toString(2).length-1},t.toGindex=r,t.toGindexBitstring=function(e,t){const r=t?Number(t).toString(2):"";if(r.length>e)throw new Error("index too large for depth");return"1"+r.padStart(e,"0")},t.convertGindexToBitstring=function(e){let t;if("string"===typeof e){if(!e.length)throw new Error(o);t=e}else{if(e<1)throw new Error(o);t=e.toString(2)}return t},t.countToDepth=function(e){return e<=1?0:(e-BigInt(1)).toString(2).length},t.iterateAtDepth=function(e,t,o){if(t+o>BigInt(1)<<BigInt(e))throw new Error("Too large for depth");let n=r(e,t);const i=n+o;return{[Symbol.iterator]:()=>({next(){if(n<i){const e=n;return n++,{done:!1,value:e}}return{done:!0,value:void 0}}})}},t.getGindicesAtDepth=function(e,t,o){if(t+o>BigInt(1)<<BigInt(e))throw new Error("Too large for depth");let n=r(e,BigInt(t));const i=[];for(let r=0;r<o;r++)i.push(n++);return i};const o="Invalid gindex";t.gindexIterator=function(e){let t;if("string"===typeof e){if(!e.length)throw new Error(o);t=e}else{if(e<1)throw new Error(o);t=e.toString(2)}let r=1;const n=()=>{if(r===t.length)return{done:!0,value:void 0};const e=Number(t[r]);return r++,{done:!1,value:e}};return{[Symbol.iterator]:()=>({next:n}),remainingBitLength:()=>t.length-r}},t.getGindexBits=function(e){let t;if("string"===typeof e){if(!e.length)throw new Error(o);t=e}else{if(e<1)throw new Error(o);t=e.toString(2)}const r=[];for(let o=1;o<t.length;o++)r.push(Number(t[o]));return r},t.concatGindices=function(e){return BigInt(e.reduce(((e,t)=>e+t.toString(2).slice(1)),"0b1"))},t.gindexSibling=function(e){return e^BigInt(1)},t.gindexParent=function(e){return e/BigInt(2)},t.gindexChild=function(e,t){return e*BigInt(2)+BigInt(t)}},97034:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.isHashObject=t.uint8ArrayToHashObject=t.hashObjectToUint8Array=t.hashTwoObjects=t.hash=void 0;const o=r(97507),n=new Uint8Array(64);t.hash=function(e,t){return n.set(e,0),n.set(t,32),o.default.digest64(n)},t.hashTwoObjects=function(e,t){return o.default.digestTwoHashObjects(e,t)},t.hashObjectToUint8Array=function(e){const t=new Uint8Array(32);return o.hashObjectToByteArray(e,t,0),t},t.uint8ArrayToHashObject=function(e){return o.byteArrayToHashObject(e)},t.isHashObject=function(e){return void 0===e.length}},56050:function(e,t,r){var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r),Object.defineProperty(e,o,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||o(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(8219),t),n(r(97034),t),n(r(28984),t),n(r(37583),t),n(r(36904),t),n(r(8015),t),n(r(67684),t)},28984:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.compose=t.identity=t.LeafNode=t.BranchNode=t.Node=void 0;const o=r(97034),n="Invalid tree";class i{constructor(){this.h0=null,this.h1=0,this.h2=0,this.h3=0,this.h4=0,this.h5=0,this.h6=0,this.h7=0}applyHash(e){this.h0=e.h0,this.h1=e.h1,this.h2=e.h2,this.h3=e.h3,this.h4=e.h4,this.h5=e.h5,this.h6=e.h6,this.h7=e.h7}}t.Node=i;class s extends i{constructor(e,t){if(super(),this._left=e,this._right=t,!e||!t)throw new Error(n)}get rootHashObject(){return null===this.h0&&super.applyHash(o.hashTwoObjects(this.left.rootHashObject,this.right.rootHashObject)),this}get root(){return o.hashObjectToUint8Array(this.rootHashObject)}isLeaf(){return!1}get left(){return this._left}get right(){return this._right}rebindLeft(e){return new s(e,this.right)}rebindRight(e){return new s(this.left,e)}}t.BranchNode=s;t.LeafNode=class extends i{constructor(e){if(super(),o.isHashObject(e))this.applyHash(e);else{if(32!==e.length)throw new Error(n);this.applyHash(o.uint8ArrayToHashObject(e))}}get rootHashObject(){return this}get root(){return o.hashObjectToUint8Array(this)}isLeaf(){return!0}get left(){throw Error("LeafNode has no left node")}get right(){throw Error("LeafNode has no right node")}rebindLeft(){throw Error("LeafNode has no left node")}rebindRight(){throw Error("LeafNode has no right node")}},t.identity=function(e){return e},t.compose=function(e,t){return function(r){return t(e(r))}}},67684:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.deserializeProof=t.serializeProof=t.createNodeFromProof=t.createProof=t.ProofTypeSerialized=t.ProofType=void 0;const o=r(20675),n=r(65866);var i;!function(e){e.single="single",e.treeOffset="treeOffset"}(i=t.ProofType||(t.ProofType={})),t.ProofTypeSerialized=[i.single,i.treeOffset],t.createProof=function(e,t){switch(t.type){case i.single:{const[r,n]=o.createSingleProof(e,t.gindex);return{type:i.single,gindex:t.gindex,leaf:r,witnesses:n}}case i.treeOffset:{const[r,o]=n.createTreeOffsetProof(e,t.gindices);return{type:i.treeOffset,offsets:r,leaves:o}}default:throw new Error("Invalid proof type")}},t.createNodeFromProof=function(e){switch(e.type){case i.single:return o.createNodeFromSingleProof(e.gindex,e.leaf,e.witnesses);case i.treeOffset:return n.createNodeFromTreeOffsetProof(e.offsets,e.leaves);default:throw new Error("Invalid proof type")}},t.serializeProof=function(e){switch(e.type){case i.single:throw new Error("Not implemented");case i.treeOffset:{const r=new Uint8Array(1+n.computeTreeOffsetProofSerializedLength(e.offsets,e.leaves));return r[0]=t.ProofTypeSerialized.indexOf(i.treeOffset),n.serializeTreeOffsetProof(r,1,e.offsets,e.leaves),r}default:throw new Error("Invalid proof type")}},t.deserializeProof=function(e){const r=t.ProofTypeSerialized[e[0]];if(!r)throw new Error("Invalid proof type");switch(r){case i.single:throw new Error("Not implemented");case i.treeOffset:{const[t,r]=n.deserializeTreeOffsetProof(e,1);return{type:i.treeOffset,offsets:t,leaves:r}}default:throw new Error("Invalid proof type")}}},20675:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.createNodeFromSingleProof=t.createSingleProof=t.ERR_INVALID_NAV=void 0;const o=r(28984),n=r(8219);t.ERR_INVALID_NAV="Invalid tree navigation",t.createSingleProof=function(e,r){const o=[];let i=e;for(const s of n.gindexIterator(r))if(s){if(i.isLeaf())throw new Error(t.ERR_INVALID_NAV);o.push(i.left.root),i=i.right}else{if(i.isLeaf())throw new Error(t.ERR_INVALID_NAV);o.push(i.right.root),i=i.left}return[i.root,o.reverse()]},t.createNodeFromSingleProof=function(e,t,r){let n=new o.LeafNode(t);const i=r.reverse();for(;e>1;){const t=new o.LeafNode(i.pop());n=e%BigInt(2)===BigInt(0)?new o.BranchNode(n,t):new o.BranchNode(t,n),e/=BigInt(2)}return n}},65866:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.deserializeTreeOffsetProof=t.serializeTreeOffsetProof=t.computeTreeOffsetProofSerializedLength=t.createNodeFromTreeOffsetProof=t.createTreeOffsetProof=t.treeOffsetProofToNode=t.nodeToTreeOffsetProof=void 0;const o=r(28984),n=r(16782);function i(e,t,r){if(r.length&&r[0].startsWith(t)){if(t===r[0])return r.shift(),[[],[e.root]];{const[o,n]=i(e.left,t+"0",r),[s,f]=i(e.right,t+"1",r);return[[n.length].concat(o,s),n.concat(f)]}}return[[],[]]}function s(e,t){if(t.length){if(1===t.length)return new o.LeafNode(t[0]);{const r=e[0];return new o.BranchNode(s(e.slice(1,r),t.slice(0,r)),s(e.slice(r),t.slice(r)))}}throw new Error("Proof must contain gt 0 leaves")}t.nodeToTreeOffsetProof=i,t.treeOffsetProofToNode=s,t.createTreeOffsetProof=function(e,t){return i(e,"1",n.computeMultiProofBitstrings(t.map((e=>e.toString(2)))))},t.createNodeFromTreeOffsetProof=function(e,t){return s(e,t)},t.computeTreeOffsetProofSerializedLength=function(e,t){return 2*(e.length+1)+32*t.length},t.serializeTreeOffsetProof=function(e,t,r,o){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);n.setUint16(t,o.length,!0);const i=t+2;for(let f=0;f<r.length;f++)n.setUint16(2*f+i,r[f],!0);const s=i+2*r.length;for(let f=0;f<o.length;f++)e.set(o[f],32*f+s)},t.deserializeTreeOffsetProof=function(e,t){const r=new DataView(e.buffer,e.byteOffset,e.byteLength),o=r.getUint16(t,!0);if(e.length<2*(o-1)+32*o)throw new Error("Unable to deserialize tree offset proof: not enough bytes");const n=t+2,i=Array.from({length:o-1},((e,t)=>r.getUint16(2*t+n,!0))),s=n+2*i.length;return[i,Array.from({length:o},((t,r)=>e.subarray(32*r+s,32*(r+1)+s)))]}},16782:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.computeMultiProofBitstrings=t.filterParentBitstrings=t.sortInOrderBitstrings=t.computeProofBitstrings=t.computeProofGindices=void 0;const o=r(8219);function n(e){const t=new Set,r=new Set;let o=e;for(;o.length>1;){t.add(o);const e=o[o.length-1],n=o.substring(0,o.length-1);r.add(n+(1^Number(e))),o=n}return{path:t,branch:r}}function i(e,t){return e.length?e.map((e=>e.padEnd(t))).sort().map((e=>e.trim())):[]}function s(e){const t=e.sort(((e,t)=>e.length-t.length)),r=[];e:for(let o=0;o<t.length;o++){const e=t[o];for(let r=o+1;r<t.length;r++){if(t[r].startsWith(e))continue e}r.push(e)}return r}t.computeProofGindices=function(e){const t=new Set,r=new Set;let n=e;for(;n>1;)t.add(n),r.add(o.gindexSibling(n)),n=o.gindexParent(n);return{path:t,branch:r}},t.computeProofBitstrings=n,t.sortInOrderBitstrings=i,t.filterParentBitstrings=s,t.computeMultiProofBitstrings=function(e){const t=new Set(s(e)),r=new Set,o=new Set;let f=1;for(const i of t){i.length>f&&(f=i.length);const{path:e,branch:t}=n(i);e.forEach((e=>r.add(e))),t.forEach((e=>o.add(e)))}return r.forEach((e=>o.delete(e))),o.forEach((e=>t.add(e))),i(Array.from(t),f)}},36904:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.subtreeFillToContents=t.subtreeFillToLength=t.subtreeFillToDepth=void 0;const o=r(28984),n=r(37583),i="Too many nodes";function s(e,t){let r=e;for(;t>0;)r=new o.BranchNode(r,r),t--;return r}t.subtreeFillToDepth=s,t.subtreeFillToLength=function e(t,r,f){const h=1<<r;if(f>h)throw new Error(i);if(f===h)return s(t,r);if(0===r){if(1===f)return t;throw new Error("Navigation error")}if(1===r)return new o.BranchNode(t,f>1?t:n.zeroNode(0));const c=h>>1;return f<=c?new o.BranchNode(e(t,r-1,f),n.zeroNode(r-1)):new o.BranchNode(s(t,r-1),e(t,r-1,f-c))},t.subtreeFillToContents=function e(t,r){const s=2**r;if(t.length>s)throw new Error(i);if(0===r)return t.length?t[0]:n.zeroNode(0);if(1===r)return t.length?new o.BranchNode(t[0],t[1]||n.zeroNode(0)):n.zeroNode(1);const f=Math.floor(s/2);return t.length<=f?new o.BranchNode(e(t,r-1),n.zeroNode(r-1)):new o.BranchNode(e(t.slice(0,Number(f)),r-1),e(t.slice(Number(f)),r-1))}},8015:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.Tree=void 0;const o=r(8219),n=r(28984),i=r(67684),s=r(20675),f=r(37583),h="Invalid tree operation",c="Param must be >= 0",a="Count extends beyond depth limit";class l{constructor(e,t){this._node=e,t&&("undefined"===typeof WeakRef?this.hook=t:this.hook=new WeakRef(t))}static createFromProof(e){return new l(i.createNodeFromProof(e))}get rootNode(){return this._node}set rootNode(e){if(this._node=e,this.hook)if("undefined"===typeof WeakRef)this.hook(this);else{const e=this.hook.deref();e?e(this):this.hook=void 0}}get root(){return this.rootNode.root}getNode(e){let t=this.rootNode;const r=o.convertGindexToBitstring(e);for(let o=1;o<r.length;o++)if("1"===r[o]){if(t.isLeaf())throw new Error(h);t=t.right}else{if(t.isLeaf())throw new Error(h);t=t.left}return t}setNode(e,t,r=!1){let o;if("string"===typeof e)o=e;else{if(e<1)throw new Error("Invalid gindex < 1");o=e.toString(2)}const n=this.getParentNodes(o,r);this.rebindNodeToRoot(o,n,t)}getRoot(e){return this.getNode(e).root}getHashObject(e){return this.getNode(e)}setRoot(e,t,r=!1){this.setNode(e,new n.LeafNode(t),r)}setHashObject(e,t,r=!1){this.setNode(e,new n.LeafNode(t),r)}setHashObjectFn(e,t,r=!1){let o;if("string"===typeof e)o=e;else{if(e<1)throw new Error("Invalid gindex < 1");o=e.toString(2)}const i=this.getParentNodes(o,r),s=i[i.length-1],f="1"===o[o.length-1]?s.right:s.left,h=new n.LeafNode(t(f));this.rebindNodeToRoot(o,i,h)}getSubtree(e){return new l(this.getNode(e),(t=>this.setNode(e,t.rootNode)))}setSubtree(e,t,r=!1){this.setNode(e,t.rootNode,r)}clone(){return new l(this.rootNode)}getSingleProof(e){return s.createSingleProof(this.rootNode,e)[1]}*iterateNodesAtDepth(e,t,r){if(t<0||r<0||e<0)throw new Error(c);if(BigInt(1)<<BigInt(e)<t+r)throw new Error(a);if(0===r)return;if(0===e)return void(yield this.rootNode);let n=this.rootNode,i=0;const s=o.toGindexBitstring(e,t),f=[];for(let o=1;o<s.length;o++){const e=Number(s[o]);if(f.push([n,e]),e){if(n.isLeaf())throw new Error(h);n=n.right}else{if(n.isLeaf())throw new Error(h);n=n.left}}for(;f.length&&i<r;){if(yield n,i++,i===r)return;do{const[t,r]=f.pop();if(!r){if(f.push([t,1]),t.isLeaf())throw new Error(h);for(n=t.right;f.length!==e;){if(f.push([n,0]),n.isLeaf())throw new Error(h);n=n.left}}}while(f.length&&f.length!==e)}}getNodesAtDepth(e,t,r){if(t<0||r<0||e<0)throw new Error(c);if(BigInt(1)<<BigInt(e)<t+r)throw new Error(a);if(0===r)return[];if(0===e)return[this.rootNode];const n=[];let i=this.rootNode,s=0;const f=o.toGindexBitstring(e,t),l=[];for(let o=1;o<f.length;o++){const e=Number(f[o]);if(l.push([i,e]),e){if(i.isLeaf())throw new Error(h);i=i.right}else{if(i.isLeaf())throw new Error(h);i=i.left}}for(;l.length&&s<r&&(n.push(i),s++,s!==r);)do{const[t,r]=l.pop();if(!r){if(l.push([t,1]),t.isLeaf())throw new Error(h);for(i=t.right;l.length!==e;){if(l.push([i,0]),i.isLeaf())throw new Error(h);i=i.left}}}while(l.length&&l.length!==e);return n}getProof(e){return i.createProof(this.rootNode,e)}getParentNodes(e,t=!1){let r=this.rootNode;const o=[this.rootNode];for(let n=1;n<e.length-1;n++){if(r.isLeaf()){if(!t)throw new Error(h);r=f.zeroNode(e.length-n)}r="1"===e[n]?r.right:r.left,o.push(r)}return o}rebindNodeToRoot(e,t,r){let o=r;for(let n=e.length-1;n>=1;n--)o="1"===e[n]?t[n-1].rebindRight(o):t[n-1].rebindLeft(o);this.rootNode=o}}t.Tree=l},37583:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.zeroNode=void 0;const o=r(28984),n=[new o.LeafNode(new Uint8Array(32))];t.zeroNode=function(e){if(e>=n.length)for(let t=n.length;t<=e;t++)n[t]=new o.BranchNode(n[t-1],n[t-1]);return n[e]}}}]);