{"pageProps":{"overviewPageData":{"id":"generalized_indices","contentHtml":"<div id='Generalized%20Merkle%20Tree%20Index' align='center'>\n<h1>Generalized Merkle tree Index</h1>\n<br/>\n</div>\n<div align='start'>\n<p>The <code>hash-tree-root</code> of all SSZ types merkleizes the contents as a binary tree.\nIn such a binary tree, the path to any node from the root can be described by a <code>bitfield</code></p>\n<p>This <code>bitfield</code> can also be expressed as an integer, called a <strong><code>generalized index</code></strong> in SSZ.\nThe generalized index value for a node in a binary tree is <code>2**depth + index</code>, starting with a 1 for the root.\nVisually, this looks as follows:</p>\n<pre><code>    1\n 2     3\n4 5   6 7\n   ...\n</code></pre>\n<p>TODO: VISUALIZE GENERALIZED MERKLE TREE INDEX</p>\n<p>Like the bitfield form that is extended with a <code>0</code> or <code>1</code> for each child,\nthe generalized index has the convenient property that the two children of node <code>k</code> are <code>2k</code> and <code>2k+1</code>.</p>\n<br/>\n</div>\n<div id='Combination%20and%20Slicing' align='center'>\n<h2>Combination and slicing</h2>\n</div>\n<div align='start'>\n<br />\n<p>To navigate from <code>A</code> to <code>B</code> to <code>C</code>, where <code>B</code> is in the subtree of <code>A</code> and <code>C</code> in the subtree of <code>B</code>, the generalized indices can be composed and sliced:</p>\n<p>A generalized index is composed of a leading bit <code>1</code> for the root, and the remainder navigates the path in binary tree.</p>\n<p>These navigation parts <code>AB</code> and <code>BC</code> can be concatenated to get the navigation part <code>AC</code>: <code>AB ++ BC &#x3C;-> AC</code>.\nAnd then a <code>1</code> is prepended again to delimit the exact length of the path and represent the root.</p>\n<br />\n</div>\n<div id='Flat%20Indexing' align='center>\n<h2>Flat Indexing</h2>\n<br />\n</div>\n<div align='start'>\n<p>For implementation purposes, the generalized index matches the position of a node in the linear representation of the Merkle tree, as computed by this function:</p>\n<pre><code class=\"language-python\">def merkle_tree(leaves: Sequence[Bytes32]) -> Sequence[Bytes32]:\n    padded_length = get_next_power_of_two(len(leaves))\n    o = [Bytes32()] * padded_length + list(leaves) + [Bytes32()] * (padded_length - len(leaves))\n    for i in range(padded_length - 1, 0, -1):\n        o[i] = hash(o[i * 2] + o[i * 2 + 1])\n    return o\n</code></pre>\n<br />\n</div>\n<div id='Representation' align='center'>\n<h2>Representation</h2>\n</div>\n<div align='start'>\n<br />\n<p>In the SSZ spec, a generalized index is represented as a custom integer type: <code>GeneralizedIndex</code> (of arbitrary bitlength).\nIt can be also be represented as a Bitvector/Bitlist object.</p>\n<p>Note that for <code>bitfields</code>, the root bit is not encoded in SSZ:</p>\n<ul>\n<li><strong><code>bitlists</code></strong>: SSZ already naturally appends 1 to the serialized bits, to make a difference in bitlengths.</li>\n<li><strong><code>bitvectors</code></strong>: vectors are of fixed length, and do not need the delimiting bit.</li>\n</ul>\n","title":"Generalized Indices","section":"Navigation","toc":["Generalized Merkle Tree Index","Combination and Slicing","Flat Indexing","Representation"],"prev":"merkle_proof_helper_functions","next":"ssz_object_to_index"}},"__N_SSG":true}