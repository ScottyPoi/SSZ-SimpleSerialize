{"pageProps":{"overviewPageData":{"id":"bitfields","contentHtml":"<div align='center' id='Bitfields'>\n<h1>Bitfields</h1>\n<h5><code>Bitfields</code> are collections of <code>booleans</code></h5>\n<h6><strong><code>boolean</code></strong> values (<code>true/false</code>, <code>0/1</code>, <code>yes/no</code>) are each exactly <code>1 bit</code>.  For efficiency, they can be packed together tightly into special <em><strong><code>Vectors</code></strong></em> or <em><strong><code>Lists</code></strong></em> called <strong><code>Bitfields</code></strong></h6>\n<br/>\n</div>\n<div align='start'>\n<h3>Bitvector / Bitlist</h3>\n<ul>\n<li>\n<h5>A <strong><code>Bitvector</code></strong> is a <strong><code>Vector</code></strong> of <code>boolean</code> values, with a <code>fixed size</code> of <code>N</code></h5>\n</li>\n<li>\n<h5>A <strong><code>Bitlist</code></strong> is a <strong><code>List</code></strong> of <code>boolean</code> values, with a <code>limit</code> of <code>N</code></h5>\n</li>\n<li>While these <em>could</em> be treated as <code>Vector[boolean, N]</code> and <code>List[boolean, N]</code>, SSZ offers a more efficient method for serializing <em><strong><code>bitfields</code></strong></em></li>\n</ul>\n</div>\n<div align='center' id='BitVectors'>\n<h2>Bitvector</h2>\n</div>\n<div align='start'>\n<br/>\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>Bitvector[N]</code></li>\n</ul>\n</li>\n<li>\n<h6><code>Default value</code>:</h6>\n<ul>\n<li><code>N bits</code>, all set to <code>0</code></li>\n</ul>\n</li>\n<li>\n<h6>Illegal type:</h6>\n<ul>\n<li><code>Bitvector[0]</code> is an illegal type, since fixed-length types many not have 0 byte-length representations</li>\n</ul>\n</li>\n<li>\n<h6>Serialization:</h6>\n<ul>\n<li>A fixed-length sequence of <code>N</code> bits, packed into <code>(N + 7) // 8</code> bytes.</li>\n<li>a bit at sequence index <code>i</code> is put into byte <code>i // 8</code> and matches <code>1 &#x3C;&#x3C; (i % 8)</code> within that byte</li>\n<li>If <code>N</code> is not a multiple of 8, the last byte is packed with zeroes</li>\n</ul>\n</li>\n<li>\n<h6>Merkleization</h6>\n<ul>\n<li>A bitvector is merkleized by serializing it, and then merkleizing it as a <code>Vector[byte, ((N + 7) // 8)]</code></li>\n</ul>\n</li>\n</ul>\n<br />\n</div>\n<div id='BitLists' align='center'>\n<h2>Bitlist</h2>\n<h5>A bitlist is a <strong><code>dynamic-length sequence</code></strong>, with a limit of <code>N</code> bits, packed into bytes.</h5>\n</div>\n<div align='start'>\n<br />\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>Bitlist[N]</code></li>\n</ul>\n</li>\n<li>\n<h6><code>Default value</code>**:</h6>\n<ul>\n<li><code>0</code> bits, i.e. an <code>empty bitlist</code></li>\n</ul>\n</li>\n<li>\n<h6>Serialization</h6>\n<ul>\n<li>a bit at sequence index <code>i</code> is put into byte <code>i // 8</code> and matches <code>1 &#x3C;&#x3C; (i % 8)</code> within that byte</li>\n<li>From the offset coding, the length (in bytes) of the bitlist is known. An additional 1 bit is added to the end, at index e, where e is the length of the bitlist (not the limit), so that the length in bits will also be known</li>\n<li>This <em>delimiting</em> <code>1</code> bit is put in what would effectively be the bitfield index <code>bit_length(bitlist_value)</code>.</li>\n<li>Note that for an empty bitlist that would be the first bit at index 0: A single zeroed byte, or empty bytes, is illegal as bitlist representation.</li>\n</ul>\n</li>\n<li>\n<h6>Size:</h6>\n<ul>\n<li>Because of this delimiting bit, the total byte length for serialization purposes is: <code>(((N + 1) + 7) // 8) == ((N // 8) + 1)</code></li>\n</ul>\n</li>\n<li>\n<h6>Merkleization</h6>\n<ul>\n<li>For merkleization, the length of the bitlist is mixed in with the root, and hence the delimiting bit is not used for merkleization.</li>\n<li>Similarly to a <code>List</code>, the subtree is padded to fit the limit of the bitlist.</li>\n</ul>\n</li>\n</ul>\n<img src='/bitlist-sedes.jpg' alt='bitlistsedes' class='img-fluid'/>\n","title":"BitFields","section":"Types","toc":["Bitfields","BitVectors","BitLists"]}},"__N_SSG":true}