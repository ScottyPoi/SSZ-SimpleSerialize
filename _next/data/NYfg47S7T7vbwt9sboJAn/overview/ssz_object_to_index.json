{"pageProps":{"overviewPageData":{"id":"ssz_object_to_index","contentHtml":"<h1>SSZ object to index</h1>\n<p>SSZ provides a set of functions, called PATHS to navigate the hash tree of SSZ objects.</p>\n<h4>Hash Tree:</h4>\n<p>We can describe the hash tree of any SSZ object, rooted in <code>hash_tree_root(object)</code>, as a <strong>binary Merkle tree</strong> whose depth may vary.</p>\n<p>For example, an object <code>{x: bytes32, y: List[uint64]}</code> would look as follows:</p>\n<pre><code>     root\n    /    \\\n   x    y_root\n        /    \\\ny_data_root  len(y)\n    / \\\n   /\\ /\\\n  .......\n</code></pre>\n<h4>PATH:</h4>\n<p>A <code>PATH</code> is way of describing a function that takes as input an SSZ object and outputs some specific (possibly deeply nested) member.\nPaths are represented as <code>lists</code>.</p>\n<ul>\n<li>The human-readable form is simply a <code>/</code>-separated list of path components, starting with the name of the root type.\n<ul>\n<li>Example: <code>MyType/some_field/abc_list/123/foobar</code></li>\n<li>Languages may have different levels of expressiveness for these type of paths, and static languages may require templates or code-generation for this.</li>\n</ul>\n</li>\n<li>In \"encoded form\", they are lists of uint64 values</li>\n</ul>\n<h5>SSZVariableName</h5>\n<p>We define <code>SSZVariableName</code> as the member variable name string, i.e., a path is presented as a sequence of integers and <code>SSZVariableName</code>.</p>\n<h4><code>PATH</code> functions:</h4>\n<ul>\n<li>\n<h5><code>item_length</code>:</h5>\n<ul>\n<li>\n<details><summary>See Pseudocode</summary><br/>\n<pre><code class=\"language-python\">def item_length(typ: SSZType) -> int:\n\"\"\"\nReturn the number of bytes in a basic type, or 32 (a full hash) for compound types.\n\"\"\"\nif issubclass(typ, BasicValue):\n    return typ.byte_len\nelse:\n        return 32\n</code></pre>\n</details>\n<br/>\n</li>\n<li>\n<p>Takes a SSZType as input</p>\n</li>\n<li>\n<p>Returns the number of bytes in a basic type</p>\n</li>\n<li>\n<p>Returns 32 (a full hash) for compound types.</p>\n</li>\n</ul>\n</li>\n<li>\n<h5><code>get_elem_type</code></h5>\n<ul>\n<li>\n<details><summary>See Pseudocode</summary><br/>\n<pre><code class=\"language-python\">def get_elem_type(typ: Union[BaseBytes, BaseList, Container],\n              index_or_variable_name: Union[int, SSZVariableName]) -> SSZType:\n\"\"\"\nReturn the type of the element of an object of the given type with the given index\nor member variable name (eg. `7` for `x[7]`, `\"foo\"` for `x.foo`)\n\"\"\"\nreturn typ.get_fields()[index_or_variable_name] if issubclass(typ, Container) else typ.elem_type\n</code></pre>\n</details>\n</li>\n<li>\n<p>Return the type of the element of an object of the given type with the given index</p>\n</li>\n<li>\n<p>or Return member variable name (eg. <code>7</code> for <code>x[7]</code>, <code>\"foo\"</code> for <code>x.foo</code>)</p>\n</li>\n</ul>\n</li>\n<li>\n<h5><code>chunk_count</code></h5>\n<ul>\n<li>\n<details><summary>See Pseudocode</summary><br/>\n<pre><code class=\"language-python\">def chunk_count(typ: SSZType) -> int:\n\"\"\"\nReturn the number of hashes needed to represent the top-level elements in the given type\n(eg. `x.foo` or `x[7]` but not `x[7].bar` or `x.foo.baz`). In all cases except lists/vectors\nof basic types, this is simply the number of top-level elements, as each element gets one\nhash. For lists/vectors of basic types, it is often fewer because multiple basic elements\ncan be packed into one 32-byte chunk.\n\"\"\"\n# typ.length describes the limit for list types, or the length for vector types.\nif issubclass(typ, BasicValue):\n    return 1\nelif issubclass(typ, Bits):\n    return (typ.length + 255) // 256\nelif issubclass(typ, Elements):\n    return (typ.length * item_length(typ.elem_type) + 31) // 32\nelif issubclass(typ, Container):\n    return len(typ.get_fields())\nelse:\n    raise Exception(f\"Type not supported: {typ}\")\n</code></pre>\n</details>\n</li>\n<li>\n<p>Return the number of hashes needed to represent the top-level elements in the given type</p>\n<ul>\n<li>(eg. <code>x.foo</code> or <code>x[7]</code> but not <code>x[7].bar</code> or <code>x.foo.baz</code>).</li>\n</ul>\n</li>\n<li>\n<p>In all cases except lists/vectors of basic types, this is simply the number of top-level elements, as each element gets one hash.</p>\n</li>\n<li>\n<p>For lists/vectors of basic types, it is often fewer because multiple basic elementscan be packed into one 32-byte chunk.</p>\n</li>\n<li>\n<p>typ.length describes the limit for list types, or the length for vector types.</p>\n</li>\n</ul>\n</li>\n<li>\n<h5><code>get_item_position</code></h5>\n<ul>\n<li>\n<details><summary>See Pseudocode</summary><br>\n<pre><code class=\"language-python\">def get_item_position(typ: SSZType, index_or_variable_name: Union[int, SSZVariableName]) -> Tuple[int, int, int]:\n\"\"\"\nReturn three variables:\n    (i) the index of the chunk in which the given element of the item is represented;\n    (ii) the starting byte position within the chunk;\n    (iii) the ending byte position within the chunk.\nFor example: for a 6-item list of uint64 values, index=2 will return (0, 16, 24), index=5 will return (1, 8, 16)\n\"\"\"\nif issubclass(typ, Elements):\n    index = int(index_or_variable_name)\n    start = index * item_length(typ.elem_type)\n    return start // 32, start % 32, start % 32 + item_length(typ.elem_type)\nelif issubclass(typ, Container):\n    variable_name = index_or_variable_name\n    return typ.get_field_names().index(variable_name), 0, item_length(get_elem_type(typ, variable_name))\nelse:\n    raise Exception(\"Only lists/vectors/containers supported\")\n</code></pre>\n</details>\n</li>\n<li>\n<p>Return three variables:</p>\n<ul>\n<li>(i) the index of the chunk in which the given element of the item is represented;</li>\n<li>(ii) the starting byte position within the chunk;</li>\n<li>(iii) the ending byte position within the chunk.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<h5><code>get_generalized_index</code></h5>\n<ul>\n<li>\n<details><summary>See Pseudocode</summary><br>\n<pre><code class=\"language-python\">def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -> GeneralizedIndex:\n\"\"\"\nConverts a path (eg. `[7, \"foo\", 3]` for `x[7].foo[3]`, `[12, \"bar\", \"__len__\"]` for\n`len(x[12].bar)`) into the generalized index representing its position in the Merkle tree.\n\"\"\"\nroot = GeneralizedIndex(1)\nfor p in path:\n    assert not issubclass(typ, BasicValue)  # If we descend to a basic type, the path cannot continue further\n    if p == '__len__':\n        typ = uint64\n        assert issubclass(typ, (List, ByteList))\n        root = GeneralizedIndex(root * 2 + 1)\n    else:\n        pos, _, _ = get_item_position(typ, p)\n        base_index = (GeneralizedIndex(2) if issubclass(typ, (List, ByteList)) else GeneralizedIndex(1))\n        root = GeneralizedIndex(root * base_index * get_power_of_two_ceil(chunk_count(typ)) + pos)\n        typ = get_elem_type(typ, p)\nreturn root \n</code></pre>\n</details>\n</li>\n<li>\n<p>Converts a path</p>\n<ul>\n<li>(eg. <code>[7, \"foo\", 3]</code> for <code>x[7].foo[3]</code>, <code>[12, \"bar\", \"__len__\"]</code>)</li>\n</ul>\n</li>\n<li>\n<p>into the generalized index representing its position in the Merkle tree.</p>\n<ul>\n<li><code>len(x[12].bar)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","title":"SSZ Object to Index","toc":[]}},"__N_SSG":true}