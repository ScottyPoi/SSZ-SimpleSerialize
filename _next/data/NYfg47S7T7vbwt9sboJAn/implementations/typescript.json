{"pageProps":{"implementationsPageData":{"id":"typescript","contentHtml":"<h1>From <strong>Lodestar by Chainsafe</strong></h1>\n<p><a href=\"https://travis-ci.com/ChainSafe/lodestar\"><img src=\"https://travis-ci.com/ChainSafe/lodestar.svg?branch=master\" alt=\"Build Status\"></a>\n<img src=\"https://img.shields.io/badge/ES-2020-yellow\" alt=\"ES Version\">\n<img src=\"https://img.shields.io/badge/node-12.x-green\" alt=\"Node Version\"></p>\n<h2>Summary</h2>\n<p>Simple Serialize (SSZ) is <a href=\"https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md\">an Eth2 standard</a> that defines how Eth2 consensus objects are serialized and merkleized.</p>\n<p>SSZ is a type system that defines:</p>\n<ul>\n<li>efficient serialization / deserialization</li>\n<li>stable merkleization</li>\n<li>default constructor</li>\n</ul>\n<p>Additionally, this library allows for additional operations:</p>\n<ul>\n<li>equality</li>\n<li>valid value assertion</li>\n<li>copy / clone</li>\n<li>to / from json-serializable object</li>\n</ul>\n<h2>Install</h2>\n<p><code>npm install @chainsafe/ssz</code></p>\n<h2>Usage</h2>\n<pre><code class=\"language-typescript\">import {ContainerType, ByteVectorType} from \"@chainsafe/ssz\";\n\n// Creates a \"Keypair\" SSZ data type (a private key of 32 bytes, a public key of 48 bytes)\nconst Keypair = new ContainerType({\n  fields: {\n    priv: new ByteVectorType({\n      length: 32,\n    }),\n    pub: new ByteVectorType({\n      length: 48,\n    }),\n  },\n});\n\n// You may want a corresponding typescript interface for Keypair\nimport {ByteVector} from \"@chainsafe/ssz\";\ninterface Keypair {\n  priv: ByteVector;\n  pub: ByteVector;\n}\n\n// Now you can perform different operations on Keypair objects\n\nconst kp = Keypair.defaultValue(); // Create a default Keypair\n\nkp.priv; // => ByteVector [0,0,0,...], length 32\nkp.pub; // => ByteVector [0,0,0, ...], length 48\n\nconst serialized: Uint8Array = Keypair.serialize(kp); // serialize the object to a byte array\nconst root: Uint8Array = Keypair.hashTreeRoot(kp); // get the merkle root of the object\nconst isEqual: boolean = Keypair.equals(kp, kp); // check equality between two keypairs\nconst kp2: Keypair = Keypair.clone(kp); // create a copy of the object\nconst kp3: Keypair = Keypair.deserialize(serialized); // deserialize a serialized object\nconst jsonKp = Keypair.toJson(kp); // convert the object to a json-serializable representation (binary data is converted to hex strings)\nJSON.stringify(jsonKp);\nKeypair.fromJson(jsonKp); // convert the json-serializable representation to the object\n\n// The merkle-tree-backed representation of a Keypair may be created / operated on\nconst kp2: TreeBacked&#x3C;Keypair> = Keypair.defaultTreeBacked();\n\n// All of the same operations can be performed on tree-backed values\nKeypair.serialize(kp2);\n</code></pre>\n<h3>ETH2 Objects</h3>\n<p>For Eth2 datatypes (eg: <code>BeaconBlock</code>, <code>DepositData</code>, <code>BeaconState</code>, etc), see <a href=\"https://github.com/ChainSafe/lodestar/tree/master/packages/lodestar-types\"><code>@chainsafe/lodestar-types</code></a>.</p>\n<h2>Additional notes</h2>\n<h3>Backings</h3>\n<p>This library operates on values of several kinds of 'backings', or underlying representations of data. Each backing has runtime tradeoffs for the above operations that arise from the nature of the underlying representation.</p>\n<p>Effort has been made to minimize the differences between backings for the core API, which includes the above operations, property getter/setters, and iteration (value iteration for vectors/lists and enumerable key iteration for containers).</p>\n<p>We support the following backings, which correspond to the core operations of serialization and merkleization:</p>\n<ul>\n<li>Structural - This backing has a native javascript type representation.</li>\n</ul>\n<p>Containers are constructed as js Objects, vectors and lists as Arrays (or TypedArrays) Within operations, property access is performed using js getter notation, with gets corresponding to the structure of the value's type. Because structural non-constructor operations do not assume the underlying representation of values, all backings can be operated on in this context.</p>\n<ul>\n<li>Tree - This backing has an immutable merkle tree representation.</li>\n</ul>\n<p>The data is always represented as a tree, and within operations, the tree structure is harnessed as much as possible. Property getters return subtrees except for basic types, when the native value corresponding th that type is returned. Values backed by a tree are wrapped in an ES6 Proxy object to provide a convenient, 'structural' interface for property getters/setters.</p>\n<ul>\n<li>ByteArray - This backing has a byte array representation.</li>\n</ul>\n<p>The data is always represented as a Uint8Array, and within operations, the serialized structure is harnessed as much as possible. Property getters return sub-arrays except for basic types, when the native value corresponding to that type is returned. Values backed by an array are wrapped in an ES6 Proxy object to provide a convenient, 'structural' interface for property getters/setters.</p>\n<h2>License</h2>\n<p>Apache 2.0</p>\n","title":"typescript implementation","toc":[]}},"__N_SSG":true}