{"pageProps":{"overviewPageData":{"id":"Typing","contentHtml":"<div align='center' id='Types'>\n<h1>Typing</h1>\n<br/>\n<h2>Types</h2>\n<br/>\n<h4>All SSZ Objects represent data of one of these <strong>Types</strong>:</h4>\n<br/>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h5>Basic Types:</h5>\n<ul>\n<li>\n<h6><strong>Unisigned Integer</strong></h6>\n<ul>\n<li><code>Uint8, Uint16, Uint32, Uint64, Uint128, Uint256</code></li>\n</ul>\n</li>\n<li>\n<h6><strong>Boolean</strong></h6>\n<ul>\n<li><code>Bit, 0 or 1, True or False</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<h5>Composite Types</h5>\n<ul>\n<li>\n<h6><strong>Vector</strong></h6>\n<ul>\n<li><code>\"Fixed Length\" sequence of elements of same **Type** (homogeneous)</code></li>\n</ul>\n</li>\n<li>\n<h6><strong>List</strong></h6>\n<ul>\n<li><code>\"Variable Length\" sequence of elements of the same **Type** (homogenous)</code></li>\n</ul>\n</li>\n<li>\n<h6><strong>Container</strong></h6>\n<ul>\n<li><code>Heterogeneous ordered collection of elements</code></li>\n</ul>\n</li>\n<li>\n<h6><strong>Union</strong></h6>\n<ul>\n<li><code>A \"Union Type\" containing SSZ Types</code></li>\n</ul>\n</li>\n<li>\n<h6><strong>Root</strong></h6>\n<ul>\n<li><code>A Uint256 that represents the </code>Bytes32 hash_tree_root<code> of a nested merkle tree</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n</div>\n<div align='center' id='Aliases'>\n<br/>\n<h2>Aliases</h2>\n<br/>\n<p><strong>Types</strong> can be <strong>aliased</strong> to more specific types, good use of type aliasing can make a data-structure much clearer.<br>\nE.g. <code>BLSSignature</code> instead of <code>Vector[byte, 96]</code>.\n<br/></p>\n</div>\n<div id='Default%20Values' align='center'>\n<h2>Default values</h2>\n<br/>\n<p>All SSZ Types have a default \"zeroed\" value</p>\n</div>\n<div align='start'>\n<ul>\n<li><code>Uint</code>: 0</li>\n<li><code>Boolean</code>: False</li>\n<li><code>Vector</code>: Sequence of default values</li>\n<li><code>List</code>: Empty List</li>\n<li><code>Container</code>: Default value for each type in container</li>\n<li><code>Union</code>: Default value of \"Type_0\"</li>\n</ul>\n<br/>  \n</div>\n<div align='center'>\n<p>Default values are <em>recursive</em>; elements in composite types such as containers are initialized with their respective default initializations\n<br/></p>\n</div>\n<div align='center' id='Merkle%20Proofs'>\n<br/>\n<h2>Merkle proofs</h2>\n<br/>\n<p>Every type deterministically describes the shape of the <strong>Merkle Tree</strong> representing the type</p>\n</div>\n<div align='start'>\n<blockquote>\n<p>Most types do so statically: the shape can be constructed on compile time, and navigation is stable (See <a href=\"../navigation/generalized_indices.md\">generalized indices</a>).</p>\n</blockquote>\n<br/>\n</div>\n<div align='center'>\n<h4>Mapping a valid (to the <strong>type</strong>) merkle tree to that same <strong>type</strong> is <em>bijective</em>:</h4>\n<br/>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h5>No two different values <em>of the same type</em> can merkleize to the same root</h5>\n</li>\n<li>\n<h5>No two roots can be derived for the same value <em>of the type used for the root</em>.</h5>\n</li>\n</ul>\n<br/>\n</div>\n<div align='center'>\n<h4><strong>Different types <em>may</em> merkleize to the same root:</strong></h4>\n<br/>\n</div>\n<div align='start'>\n<h5><strong>1. Intentionally</strong>: see <a href=\"../navigation/summaries_expansions.md\">summaries and expansions</a>.</h5>\n<p>or</p>\n<h5><strong>2. Because different types have the same structure</strong></h5>\n<ul>\n<li>Two values <em>of different types</em> can merkleize to the same <code>root</code>\n<ul>\n<li>e.g. a <code>uint256(123)</code> and <code>uint8(123)</code> have the same root.</li>\n<li>Or more exceptionally, a <code>Container</code> with 4 <code>Bytes32</code> fields can have the same root as a <code>Vector[uint64, 16]</code>.</li>\n</ul>\n</li>\n</ul>\n<br />\n</div>\n<div align='center' id='Representation'>\n<br />\n<h2>Representation</h2>\n<br />\n<h4>Mapping <em>valid</em> instances of the same type to a byte sequence is <em>bijective</em>:</h4>\n</div>\n<div align='start'>\n<br />\n<ul>\n<li>\n<p><strong>Serialization:</strong> Any two different values <em>of the same type</em> cannot have the same representation.</p>\n</li>\n<li>\n<p><strong>Deserialization:</strong> Any <em>valid</em> representation <em>of a given type</em> cannot be interpreted as two different values <em>of that same type</em>:</p>\n</li>\n</ul>\n<br />\n</div>\n<div align='center'>\n<h4>Mapping <em>any</em> instance of a type to any byte sequence is <em>injective and non-surjective</em>:</h4>\n</div>\n<div align='start'>\n<br />\n<ul>\n<li>\n<p><strong>Serialization:</strong> All type instantiations can be serialized to a unique (to the type) value.</p>\n</li>\n<li>\n<p><strong>Deserialization:</strong> not all byte sequences are a valid representation for a given type, because of constraints such as:</p>\n<ul>\n<li>representation length (See <a href=\"../overview/fixed_variable_size.md\">fixed length</a>)</li>\n<li>element count (See <a href=\"./overview/complex.md#list-limits\">list limits</a>)</li>\n<li><a href=\"../overview/sequences.md#offsets\">element offsets</a></li>\n<li>delimiters (See <a href=\"./overview/bitfields.md#bitlist\">bitlists</a>)</li>\n<li>selectors (See <a href=\"./overview/union.md\">union</a>)</li>\n<li>more, this is not an exhaustive list.</li>\n</ul>\n</li>\n</ul>\n</div>\n","title":"Typing","section":"Typing","toc":["Types","Aliases","Default Values","Merkle Proofs","Representation"],"prev":"sszineth2","next":"basic"}},"__N_SSG":true}