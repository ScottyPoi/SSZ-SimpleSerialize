{"pageProps":{"overviewPageData":{"id":"overview","contentHtml":"<div align='center' id='SSZ%20Overview'>\n<h1>SSZ Overview</h1>\n<br/>\n<br/>\n<h3>This is an overview of the SSZ Specifications</h3>\n<h4>The raw specs can be found <a href=\"#/specs\">here</a>.</h4>\n<br/>\n<h3>What is SSZ?</h3>\n<br/>\n</div>\n<div align='start'>\n<h5>SSZ was created to standardize serialization for data for Eth2</h5>\n<h5>It improves upon older formats by including <code>Merkleization</code> functionality resulting in smaller, more succint proofs.</h5>\n<h5>The main use-case of SSZ is to provide a consistent encoding and merkleization framework for the core of the Eth2 protocol.</h5>\n<h5>However, use outside of the core protocol, such as in smart contracts or layer-2 solutions, is also considered and factored into the design.</h5>\n</div>\n<div align='center'>\n<br/>\n<h3>How does SSZ work?</h3>\n<br/>\n<h3>1. Serialization</h3>\n</div>\n<div align='start'>\n<br />\n<h4>SSZ provides a serialization scheme based on simply byte conversion of integers.</h4>\n<ul>\n<li>\n<h5>Simple values can be stored as <strong>booleans</strong> (1 bit) or <strong>UintN</strong>: unisigned N-bit integers from <strong>Uint8</strong> (1 byte) to <strong>Uint256</strong> (32 bytes).</h5>\n</li>\n<li>\n<h5>Arrays of simple values can be stored as fixed-sie <strong>Vectors</strong> or fixed-limit <strong>Lists</strong>.</h5>\n</li>\n<li>\n<h5>\"Key-Value\" pairs can be stored as <strong>Containers</strong></h5>\n</li>\n<li>\n<h5>SSZ also provides a serialization scheme for <strong>Union Types</strong></h5>\n</li>\n</ul>\n<h5><strong>ALL</strong> Simple types undergo basic byte serialization to fill one 32 byte <em><strong>chunk</strong></em>.</h5>\n<ul>\n<li>\n<h5>These chunks become the <em>leaves</em> of a <em>merkle-tree</em>, and undergo a binary hashing process known as <em><strong>Merkleization</strong></em> to yield a single 32-Byte <em>hash tree root</em>.</h5>\n</li>\n</ul>\n<h5>The values within complex types are serialized, and packed tightly together into 32-Byte chunks.</h5>\n<ul>\n<li>\n<h5>Objects that fill more than one 32-Byte chunk undergo <em><strong>Merkleization</strong></em> to yield one 32-Byte <em>hash-tree-root</em>.</h5>\n</li>\n<li>\n<h5>This chunked is <em>Merkleized</em> with an additional 32-byte chunk containing the serialized length of the array, to yield a 32-byte <em>hash-tree-root</em> that will represent that object in the broader <em>merkle-tree</em></h5>\n</li>\n</ul>\n</div>\n<div align='center'>\n<br/>\n<h3>2. Merkleization</h3>\n</div>\n<div align='start'>\n<br/>\n<h5>SSZ employs the power of a <em><strong>Binary Merkle Tree</strong></em> to create a single 32-byte hash representing the state of your data.</h5>\n<p>TODO: VISUALIZE MERKLE TREE IN ACTION</p>\n<br/>\n</div>\n<div align='center'>\n<br/>\n<h3>3. Proofs, Partial-proofs, Multi-proofs</h3>\n</div>\n<div align='start'>\n<br/>\n<h5>SSZ provides a complete set of universal functions to generate efficient proofs from the merkle-tree.  These proofs are small, efficient, and simple, yet provide powerful validation and look-up functionality.</h5>\n<br/>\n<hr>\n<h6>This is NOT official documentation for SSZ-SimpleSerialize. This is an interpretation and expansion on the official specifications. The content here is a living, open-source, collaborative resource, built upon the orginial inspiration for SSZ, as well as the experience of the community of developers implementing SSZ in their work</h6>\n<br/>\n<br/>\n</div>\n<div align='center'>\n<br/>\n<p>Clarifications? Corrections? Insight to offer? Please collaborate on this project at our <a href=\"#https://www.github.com/scottypoi/ssz-simpleserialize\">GitHub</a> repository</p>\n","title":"Overview","section":"Overview","toc":["SSZ Overview","Table of Contents"],"next":"design"}},"__N_SSG":true}