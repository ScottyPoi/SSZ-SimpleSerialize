{"pageProps":{"overviewPageData":{"id":"Composite_Types","contentHtml":"<div id='Composite%20Types' align='center'>\n<h1>Composite Types</h1>\n<br/>\n<p><strong>Composite Types</strong> are types that can hold multiple values at the same time, with usage similar to that of a <code>struct</code> in popular programming languages.</p>\n<br/>\n</div>\n<div align='start'>\n<p>The SSZ specs describe 4 <strong>composite types</strong>:</p>\n<ul>\n<li>\n<h6><strong><a href=\"#Vectors\">Vectors</a></strong></h6>\n<ul>\n<li><code>\"Fixed Length\" sequence of elements of same</code> <strong>Type</strong></li>\n<li><code>Homogeneous</code></li>\n</ul>\n</li>\n<li>\n<h6><strong><a href=\"#Lists\">Lists</a></strong></h6>\n<ul>\n<li><code>\"Variable Length\" sequence of elements of the same</code> <strong>Type</strong></li>\n<li><code>Homogenous</code></li>\n</ul>\n</li>\n<li>\n<h6><strong><a href=\"#Containers\">Containers</a></strong></h6>\n<ul>\n<li><code>Ordered collection of elements</code></li>\n<li><code>Hetrogeneous</code></li>\n</ul>\n</li>\n<li>\n<h6><strong><a href=\"$Unions\">Union</a></strong></h6>\n<ul>\n<li><code>A \"Union Type\" containing SSZ Types</code></li>\n</ul>\n</li>\n</ul>\n<br />\n</div>\n<div align='center'>\n<h5>These types are distinguised by their <strong>size</strong> (<code>fixed</code> or <code>variable</code>)</h5>\n<h5>And whether their contents are <code>homogeneous</code> or <code>heterogeneous</code></h5>\n<br/>\n</div>\n<div algin=start'>\n<h6>A composite object is considered <code>fixed size</code> if:</h6>\n<ul>\n<li>all of the contained elements are <code>fixed size</code></li>\n<li><code>type</code> has a <code>fixed element count</code> (e.g. <code>Lists</code> cannot be <code>fixed size</code>)</li>\n</ul>\n<br/>\n<h6>A composite object is <code>homogeneous</code> if</h6>\n<ul>\n<li>its contents are all of one <strong>type</strong></li>\n</ul>\n<h6>A composite object is <code>heterogeneous</code> if</h6>\n<ul>\n<li>it contains multiple <strong>types</strong>.</li>\n</ul>\n<br/>\n<br/>\n</div>\n<div id='Vectors' align='center'>\n<br/>\n<h2>Vectors</h2>\n<br/>\n<h4>A <strong>Vector</strong> is a sequence of elements, all of the same type <code>T</code>, and of fixed length <code>N</code>.</h4>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>Vector[T, N]</code></li>\n</ul>\n</li>\n<li>\n<h6>Default value:</h6>\n<ul>\n<li><code>[default(T)] * N</code></li>\n<li>All elements set to their <code>default value</code></li>\n</ul>\n</li>\n<li>\n<h6>Empty Vectors:</h6>\n<ul>\n<li>Empty vectors (<code>N = 0</code>) are <code>illegal types</code>, even if the element type <code>T</code> is <code>dynamic length</code>.</li>\n<li>This is to avoid <code>fixed-length types</code> of <code>0 length</code>, which break various size assumptions in deserialization.</li>\n</ul>\n</li>\n<li>\n<h6>Serialization:</h6>\n<ul>\n<li>Serialized and deserialized like a <a href=\"../overview/composite_objects.md\">Sequence</a> of the <code>values</code>, all of type <code>T</code>.</li>\n</ul>\n</li>\n<li>\n<h6>Merkleization</h6>\n<ul>\n<li><code>root = merkle_subtree(chunkify(values))</code>, see <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a> and <a href=\"../merkleization/chunking.md\"><code>chunkify</code></a></li>\n</ul>\n</li>\n</ul>\n<br/>\n</div>\n<div align='center' id='Lists'>\n<br/>\n<h2>Lists</h2>\n<br/>\n<h4>A List is a sequence of elements, all of the same type <code>T</code>, and can be any length from <code>0</code> to <code>N</code> (inclusive).</h4>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>List[T, N]</code></li>\n</ul>\n</li>\n<li>\n<h6>Default value:</h6>\n<ul>\n<li><code>[]</code>, i.e. empty list.</li>\n</ul>\n</li>\n<li>\n<h6>List Limits</h6>\n<ul>\n<li>The maximum list length is preset as <code>N</code> and called the \"list limit\".</li>\n<li>This limit is preset for two primary reasons:\n<ol>\n<li>Stable merkleization: there are no variable numbers in the hash-tree-root definition.</li>\n<li>Strong guarantees on inputs: lists should never contain more elements than their limit states it was designed for.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<h6>Serialization</h6>\n<ul>\n<li>Serialized and deserialized like a <a href=\"../representation/sequences.md\">Sequence</a> of the <code>values</code>, all of type <code>T</code>.</li>\n<li>The limit of the list should be enforced, to ensure that no more than <code>N</code> elements are serialized or deserialized.</li>\n<li>A list is by definition variable-size, but this does not necessarily mean that its <em>elements</em> are.</li>\n</ul>\n</li>\n<li>\n<h6>Merkleization</h6>\n<ul>\n<li>The contents subtree (not including the length mix-in) is padded to fit the limit of the bitlist.</li>\n<li><code>root = mix_in_num(merkle_subtree(chunkify(values), limit=chunk_count(List[T, N])), length)</code>,</li>\n<li>see <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>,</li>\n<li><a href=\"../merkleization/chunkify.md\"><code>chunkify, chunk_count</code></a> and <a href=\"../merkleization/mixin.md\"><code>mix_in_num</code></a>.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div align='center' id='Containers'>\n<br/>\n<h2>Containers</h2>\n<br/>\n<h4>Containers are ordered sequences of values of any type</h4>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>Container[(&#x3C;K_i>: &#x3C;T_i>)]</code></li>\n<li>A Container is a predefined sequence of fields, each field can be defined as any type <code>T_i</code> independently from the other fields, and is identified by a unique (relative to the other fields) name <code>K_i</code>.</li>\n</ul>\n</li>\n<li>\n<h6>Default value:</h6>\n<ul>\n<li><code>Container[(&#x3C;K_i>: &#x3C;T_i>)](default(T_i)...)</code>, i.e. all fields set to their default value.</li>\n</ul>\n</li>\n<li>\n<h6>Empty Container:</h6>\n<ul>\n<li>An empty container, i.e. 0 fields, is an illegal type. Fixed-length types cannot have a 0 length serialized representation.</li>\n</ul>\n</li>\n<li>\n<h6>Serialization</h6>\n<ul>\n<li>Serialized and deserialized like a <a href=\"../representation/sequences.md\">Sequence</a> of the <code>fields</code>, each of their own type <code>T_i</code>.</li>\n</ul>\n</li>\n<li>\n<h6>Merkleization (container)</h6>\n<ul>\n<li><code>root = merkle_subtree(chunkify(fields))</code>,</li>\n<li>see <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>, <a href=\"../merkleization/chunkify.md\"><code>chunkify</code></a>.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div align='center' id='Unions'>\n<br/>\n<h2>Unions</h2>\n<br/>\n<h4><strong><a href=\"https://en.wikipedia.org/wiki/Union_type\"><code>Unions</code></a></strong> provide the ability to represent a set of predetermined types in the same tree and serialization position.</h4>\n<br/>\n</div>\n<div align='start'>\n<ul>\n<li>\n<h6>Type:</h6>\n<ul>\n<li><code>Union[type_0, type_1, ...]</code></li>\n<li>e.g. <code>union[null, uint64]</code></li>\n</ul>\n</li>\n<li>\n<h6>Default Value:</h6>\n<ul>\n<li>Default value of <code>type_0</code></li>\n</ul>\n</li>\n<li>\n<h6><code>Null</code> Types:</h6>\n<ul>\n<li>A special <code>null</code> type may be used as first type parameter to emulate an <code>Option</code>, any other type parameter than the first MUST not be <code>null</code>.</li>\n<li>A <code>null</code> as a standalone type is illegal.</li>\n</ul>\n</li>\n<li>\n<h6>Size:</h6>\n<ul>\n<li>A Union is considered to have a <code>dynamic</code> encoding-size, even if all the selectable options have the same type or happen to have the same serialized byte length.</li>\n</ul>\n</li>\n<li>\n<h6>Serialization</h6>\n<ul>\n<li><code>uint32</code> for the type index</li>\n<li>Followed by the serialization of the selected option.</li>\n<li><code>null</code> is represented as an empty byte sequence</li>\n</ul>\n</li>\n<li>\n<h6>Merkleization</h6>\n<ul>\n<li><code>mix_in_num(x, i)</code>\n<ul>\n<li>where <code>x</code> is the root of the selected option with index <code>i</code></li>\n<li>Right-padded to 32 bytes, effectively a <code>uint256</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","title":"Complsite Types","section":"Types","toc":["Composite Types","Vectors","Lists","Containers","Unions"],"prev":"basic","next":"bitfields"}},"__N_SSG":true}