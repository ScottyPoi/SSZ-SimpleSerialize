{"pageProps":{"overviewPageData":{"id":"hash_tree_root","contentHtml":"<div align='center'>\n<h1>hash_tree_root</h1>\n<p>The <code>hash_tree_root</code> function is based on the construction of a binary merkle tree in which the serialized form of the value becomes the leaves of the tree.</p>\n<p>However, the derivation of the final 32 bytes root hash does also depend on the type of a value and for some cases additional information relating to the type or length of a value is incorporated.</p>\n</div>\n<div align='start'>\n<h4><code>hash_tree_root(value)</code> of an object:</h4>\n<ul>\n<li>Basic Object or Vector of Basic Objects\n<ul>\n<li><code>merkleize(pack(value))</code></li>\n</ul>\n</li>\n<li>Bitvector\n<ul>\n<li><code>merkleize(pack_bits(value), limit=chunk_count(type))</code></li>\n</ul>\n</li>\n<li>List of Basic objects\n<ul>\n<li><code>mix_in_length(merkleize(pack(value), limit=chunk_count(type)), len(value))</code></li>\n</ul>\n</li>\n<li>Bitlist\n<ul>\n<li><code>mix_in_length(merkleize(pack_bits(value), limit=chunk_count(type)), len(value))</code></li>\n</ul>\n</li>\n<li>Vector of Composite objects or Container\n<ul>\n<li><code>merkleize([hash_tree_root(element) for element in value])</code></li>\n</ul>\n</li>\n<li>List of composite objects\n<ul>\n<li><code>mix_in_length(merkleize([hash_tree_root(element) for element in value], limit=chunk_count(type)), len(value))</code></li>\n</ul>\n</li>\n<li>Union type.\n<ul>\n<li><code>mix_in_type(merkleize(value.value), value.type_index)</code></li>\n</ul>\n</li>\n</ul>\n<br/>\n<p>It is important to note that whether a value is of a fixed or variable length type will impact upon the specification of its <code>hash_tree_root</code></p>\n<p>The <code>merkleize(chunks, limit=None)</code> helper function takes as input a series of 32-byte chunks that represent the value being processed and hence become the leaves of the binary merkle tree formed by merkleization.</p>\n<h3>Basic object or vector of basic objects (fixed length types)</h3>\n<p><code>hash_tree_root(value) = merkleize(pack(value))</code></p>\n<p>In this case the process is relatively simple as the value being merkleised will be either a uintN, boolean, vector of uintNs, or vector of booleans, and hence will be of a fixed length.</p>\n<p>The pack function takes the value, serializes it into bytes and right pads with zeros to create a multiple of <code>BYTES_PER_CHUNK</code>-byte chunks. These chunks are then merkleized as a binary tree and the root is returned.</p>\n<p>The <code>hash_tree_root</code> is therefore just the root of the binary merkle tree in which the leaves are created from the serialized form of the value (with zero padding as necessary).</p>\n<h3>Bitvector (fixed length type)</h3>\n<p><code>hash_tree_root(value) = merkleize(pack_bits(value)</code>\n<code>limit=chunk_count(type))</code></p>\n<br/>\n<p>The <code>value</code> is processed by <code>pack_bits</code> rather than <code>pack</code>.</p>\n<p><code>pack_bits</code> is a specialized form of <code>pack</code> in which the bits of the bitvector are packed into bytes directly, rather than say trying to serialize each bit individually</p>\n<p>This difference is important as generally when working with a series of bits (fixed length) a bitvector would be the preferred structure due to the storage efficiencies gained from being able to pack 32 bits into each chunk. This can be contrast to using a vector of booleans which would require one byte for each bit, and thus a series of 32 bites would require 32 * 8 = 256 bytes = 8 chunks</p>\n<p>The other noticable difference is the inclusion of the limit parameter, here set to <code>chunk_count(type)</code>. This parameter is generally used for variable length types to ensure that a buffer is included so as to allow for the maximum length of the type. As such in this instance for bitvectors, as a fixed length type, it is redundant. <code>merkleize(pack_bits(value))</code> produces an equivalent result. Again further explanation of the use of the limit parameter for the merkleize function will be provided below.</p>\n<h3>List of basic objects</h3>\n<p><code>hash_tree_root(value) = mix_in_length(merkleize(pac(value), limit=chunk_count(type)), len(value))</code></p>\n<br/>\n<p>The value being merkleized will be either a list of <code>uintN</code>s, or <code>list</code> of <code>booleans</code>. Note that a <code>list</code> of <code>booleans</code> is distinct from a <code>bitlist</code></p>\n<p>If we focus initially on the <code>merkleize(pack(value), limit=chunk_count(type))</code> part we can see that the value gets packed into chunks and we also have the limit parameter.</p>\n<p><code>Lists</code> are a variable length type and so in this case the <code>limit</code> represents an upper bound on the length; the number of chunks that would be required to represent a <code>value</code> of maximum length. In particular, the inclusion of this upper bound means that the packed <code>value</code> will be padded with zero chunks up to the limit during merkleisation, to ensure that the number of leaves being included is that for a maximum length <code>value</code> of that type.</p>\n<p>To generate the <code>hash_tree_root(value)</code> the root that results from the merkleization function is then hashed with the actual length of the value within the <code>mix_in_length</code> function to yield the final hash tree root.</p>\n<h3>Bitlist (variable length type)</h3>\n<p><code>hash_tree_root(value) = mix_in_length(merkleize(pack_bits(value), limit=chunk_count(type)), len(value))</code></p>\n<br/>\n<p>Bitlist is similar to the list case in that to generate the <code>hash_tree_root(value)</code> the root that results from the merkleisation function is then hashed with the actual length of the value within the mix_in_length function to yield the final hash tree root. i.e. <code>mix_in_length</code>(merkleization root, length).</p>\n<p>The primary difference to the list case is therefore in this case we are dealing with bits and hence the chunks required as the first input parameter to the <code>merkleize</code> function are generated using the pack_bits function rather than the pack function. As mentioned previously in the context of bitvectors, <code>pack_bits</code> is a specialized form of <code>pack</code> in which the bits of the bitlist are packed into bytes directly, rather than say trying to serialize each bit individually.</p>\n<p>This difference is important as generally when working with a series of bits (variable length) a bitlist would be the preferred structure due to the storage efficiencies gained from being able to pack 32 bits into each chunk. This can be contrast to using a list of booleans which would require one byte for each bit, and thus a series of 32 bites would require 32 * 8 = 256 bytes = 8 chunks.</p>\n<p>The inclusion of the <code>limit</code> parameter, here set to <code>chunk_count(type)</code> is also similar to the case of lists. While further details regarding the helper function <code>chunk_count</code> will be provided below, it is useful to note here that this parameter is generally used for variable length types to ensure that a buffer is included so as to allow for the maximum length of the type.</p>\n<h3>Vector of composite objects or a container</h3>\n<p><code>hash_tree_root(value) = merkleize([hash_tree_root(element) for element in value])</code></p>\n<br/>\n<p>Firslty, consider the application to vectors of composite objects and thus each element in value will be of the same type.</p>\n<p>To generate the chunks required as input to the merkleize function, each element itself becomes input to the hash_tree_root function yielding a recursive process. For example if we have a vector of uint64 lists then we have a fixed number of the uint64 lists and each of these uint64 lists would be processed by the hash_tree_root(value) = mix_in_length(merkleize(pack(value), limit=chunk_count(type)), len(value)) function. The processing of each element, i.e. each list, would yield a 32-byte hash tree root and this series of 32-byte hash tree roots then become the chunks for input to the merkleize function.</p>\n<p>As a vector is a fixed length type the limit parameter for the merkleize function is not required, as well there is no use of the mix_in_length functionality.</p>\n<p>If we now look at the application to a container; a container will have fields and so each field becomes an element to be processed by hash_tree_root; thus generating a series of 32-byte hash tree roots that become the chunks for input to the merkleize function.</p>\n<p>Again, as a container is a fixed length type the limit parameter for the merkleize function is not required, as well there is no use of the mix_in_length functionality.</p>\n<h3>List of composite objects</h3>\n<p><code>hash_tree_root(value) = mix_in_length(merkleize([hash_tree_root(element) for element in value], limit=chunk_count(type)), len(value))</code></p>\n<br/>\n<p>Similar to the processing of a vector of composite objects (and containers), a 32-byte hash tree root is generated for each element of the list thus forming the chunks to be input to the merkleize function; however, unlike the case for a vector of composite objects, the merkleize function does in this case require the limit parameter to ensure that the number of leaves being included is that for a maximum length value of that type. The actual length, as given by len(value) is then incorporated using the mix_in_length function to yield the final hash tree root for the list of composite objects.</p>\n<h3>Union</h3>\n<p><code>mix_in_type(merkleize(value.value), value.type_index)</code></p>\n","title":"hash_tree_root","toc":["hash_tree_root","Basic Objects","BitVectors","List(Basic)","Bitlist","Vector","List(Composite)","Union"],"prev":"merkleize_helper_functions","next":"merkle_proofs"}},"__N_SSG":true}