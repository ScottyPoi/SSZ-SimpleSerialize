{"pageProps":{"markdowns":[{"data":"## Types\n\nData for SSZ Serialization are represented by one or a combination of these **Types:** ehehe\n\n| Type | Notation |  | Default Value | Illegal Types |\n|---|---|---|---|---|\n| Unsigned Integer | Uint[N] | Uint8, Uint16, Uint64, Uint128, Uint256 | 0 |  |\n| Boolean | Bit | 0 or 1 / True or False / Vote A or Vote B | False |  |\n| Vector | Vector[Element Type, Length] | \"Fixed Length\" sequence of Elements of same Type (Homogeneous) | [default(type)] * length | Empty Vector (Vector[type, 0] |\n| Bitvector | Bitvector[Length] | Vector of type Boolean.  Vector[boolean, length].  Most efficient when treated as unique type. | [false] * length |  |\n| List | List[Element Type, Limit] | \"Variable Length\" sequence of Elements of same Type (Homogeneous) | Empty List ([]) |  |\n| Bitlist | Bitlist[Limit] | List of type Boolean.  List[boolean, limit].  More efficient when treated as unique type. | Empty List ([]) |  |\n| Container | Container[var_a: Type, var_b: Type, var_c: Type...] | Ordered Heteregeneous collection of Values (key/value pairs). | [default(type) for type in container] | Containers with No Fields |\n| Union | Union[type_0, type_1, ...] | Union type containing one of the given subtypes | Default of type_0 | Union[null, ...] |\n| Root | hash_tree_root(composite_type) | A 32 Byte root of a merkleized object |  |  |                            |\n\n-   ###### Basic Types:\n    -   ###### **Unisigned Integer** -  `Uint8, Uint16, Uint32, Uint64, Uint128, Uint256`\n    -   ###### **Boolean** - `Bit, 0 or 1, True or False`\n-   ###### Composite Types\n    -   ###### **Vector**    - `\"Fixed Length\" sequence of elements of same **Type** (homogeneous)`\n    -   ###### **List**    - `\"Variable Length\" sequence of elements of the same **Type** (homogenous)`\n    -   ###### **Container**    - `Heterogeneous ordered collection of elements`\n    -   ###### **Union**    - `A \"Union Type\" containing SSZ Types`\n    -   ###### **Root**    - `A Uint256 that represents the `Bytes32 hash_tree_root` of a nested merkle tree`\n\n**Different types _may_ merkleize to the same root:**\n\n-   Two values _of different types_ can merkleize to the same `root`\n    -   e.g. a `uint256(123)` and `uint8(123)` have the same root.  \n    -   Or more exceptionally, a `Container` with 4 `Bytes32` fields can have the same root as a `Vector[uint64, 16]`.\n\n##### Default values\n\nAll SSZ Types have a default \"zeroed\" value\n\n-   `Uint`: 0\n-   `Boolean`: False\n-   `Vector`: Sequence of default values\n-   `List`: Empty List \n-   `Container`: Default value for each type in container\n-   `Union`: Default value of \"Type_0\"\n\nDefault values are _recursive_; elements in composite types such as containers are initialized with their respective default initializations\n\n#### `is_zero`\n\nAn SSZ object is called zeroed (and thus, `is_zero(object)` returns true) if it is equal to the default value for that type.\n\n### Illegal types\n\n-   Empty vector types (`Vector[type, 0]`, `Bitvector[0]`) are illegal.\n-   Containers with no fields are illegal.\n-   The `null` type is only legal as the first type in a union subtype (i.e. with type index zero).\n","topic":"Typing"},{"data":"## Aliases\n\n\n**Types** can be **aliased** to more specific types, good use of type aliasing can make a data-structure much clearer.  \nE.g. \n\n`Gwei = Uint64`  \n`BLSSignature` = `Vector[byte, 96]`  \n`CommitteeBits` = `BitList[limit: MAX_VALIDATORS_PER_COMMITTEE]`  \n`Epoch` = `Uint64`  \n`Root` = `Uint256`  \n`Checkpoint` = `Container[epoch: Epoch, root: Root]`  \n`Bytes32 = Vector[byte, 32]`  \n`Bytes48 = Vector[byte, 48]`  \n`BLSPubkey = Bytes48;`  \n\n**Aliased Types** can be reused to improve readability and consistancy.  \n    \n    Attestation = Container{\n            sourceEpoch: Epoch,\n            targetEpoch: Epoch,\n            signingRoot: Root,\n    }\n\n\n","topic":"Aliases"},{"data":"\n\n# Serialization\n\n\n##### **`SimpleSerialize`** follows simple `byte` conversion, making it effective and efficient for encoding and decoding\n\n##### `Serialization` encodes the data into `Bytes32` chunks for merkleization.\n\n\n\n#### SSZ provides `serialize` and `deserialize` methods for\n\n\n- **Basic types** i.e. integers, Booleans,\n- **List** and *vectors of bits*, known as **BitLists** and **BitVectors**,\n- **Lists** and **Vectors** of `type_serializable`,\n- **Containers** with `type_serializable` *fieds*,\n- **Unions** of `serializable` *types*\n\n\n### \"Type Serializable\"\n\n\nAn object  ***that can be serialized***  is of `type_serializable`\n\n`serializable` can be thought of as a `trait`\n\nGiven a `type T`, we write `T : Serializable` if `T` extends (or \"inherits\" or \"is a\") `Serializable`.\n\n##### Each type `T:Serialiable` should offer two functionalities:\n\n- ###### Serialize:\n  - `serialize<T> : T -> seq<bytes>`\n  - Returns a sequence of bytes when applied to an object of `type T`\n- ###### Deserialize:\n  - `deserialize<T> : seq<bytes> ~-> T`\n  - Returns an object of `type T` *when it is possible* to deserialize a sequence of bytes in an object of `type T`\n\n\n\n\n##### Given two objects `O1:T` and `O2:T` where `T <: Serializable`, the pair of functions (`serialize<T>, deserialize<T>`) should be:\n\n\n\n- **Involutive**: `deserialize<T>( serialize<T>(O1) ) = O1`\n- **Injective**: `serialize<T>(O1) = serialize<T>(O2)` implies that `O1 = O2`\n\n\n\n### Deserialization\n\nBecause serialization is an ***injective*** function \n(i.e. two distinct objects of the same `type` will **`serialize`** to different `values`) \nany `bytestring` has at most one object it could **`deserialize`** to. \n\n\n- Note that deserialization requires hardening against invalid inputs. A non-exhaustive list:\n  - Offsets: out of order, out of range, mismatching minimum element size.\n  - Scope: Extra unused bytes, not aligned with element size.\n  - More elements than a list limit allows. Part of enforcing consensus.","topic":"Serialization"},{"data":"\n\n\n# Merkleization\n\n\n## The Merkle Tree\n\n\n### A **Merkle Tree** is a binary hash tree\n\n- The values of the **Leaves** of the Merkle Tree are each a `Bytes32` result of a `hash function` applied to the serialized objects stored in the tree\n- The value of any **parent** node in the Merkle Tree is the result of the same `hash function` applied to a concatenation of the values of its two **child** nodes.\n- The value of the **Root** node is the culmination of the process of hashing pairs of child nodes to reach a single node.\n  - Referred to in SSZ as `hash_tree_root`\n\n\nEvery type deterministically describes the shape of the Merkle tree representing the type:\nReasoning about the shape of a proof is abstracted away by the typing layer.\nMost types do so statically: the shape can be constructed on compile time, and navigation is stable \nSome types (e.g. those based on Sparse Merkle Trees) are not static, but are deterministic based the contents of the proof.\n\n\n## Vector\n\nVector types are fixed-length lists.  \nElements are packed tightly into 32 Byte leaves, the final leaf padded with zeros if necessary.\nA Merkle Tree for a vector with N chunks will have next_power_of_two(N) leaves.\n\n## List\n\nThe Merkle Tree for a serialized List looks like a Vector tree, with one additional level added at the top.  The hash_tree_root of the value tree is itself Hashed with a serialized Uint256 of the LIMIT of the list.\n\n### Container\n\nContainers have a leaf for each key/value pair in the container.  The Merkle Tree will expand to a power_of_two number of leaves.  \n\n### Nested Subtrees\n\nIf the value of a container field is a Composite Object, the leaf will in fact be the hash_tree_root of that object.  This becomes very useful as Containers can next inside Containers inside Containers Ad Infinitum.  The Merkle Proof for a value deeply nested inside one of these subtrees is not necessarily much larger than for any other value.  Because they share proof nodes with values further up, a multi-proof containing a deeply nested object is just as concise.","topic":"Merkle_Trees"},{"data":"## Merkle proofs\n\n\nMerkle proofs enable users to efficiently prove specific details of some data-structure that is known by a given hash.\n\nThe efficiency is achieved with a tree structure of hashes, with the data in the leaves of the tree.\nFor a proof of a set of leaves, branches to other leaves do not have to be fully encoded or hashed,\nthe starts of each such branch, together with the values to proof, are sufficient to reconstruct the root of the tree.\nCompare the reconstructed root with the trusted root the data is known by, and the proof is complete.\n\n### Accumulator\n\nMerkle trees are a type of cryptographic accumulator, and a root is a binding vector commitment to a set of contents.\nI.e. the position of the contents is also committed, not just inclusion. Changing the position of any of the contents would change the Merkle root.\n\nMembership of a leaf value, at a specific position, can be proven with witness data:\na set of hashes along the way to the root of the tree, taking `O(log(N))` space and computation for a proof, as opposed to `N` for providing the full data.\n\n## Binary Merkle Tree\n\nThe tree structure itself affects the amount of nodes, and thus the amount of hash operations, and size of the proof.\n\nOne of the few opinionated choices made by SSZ for Eth2 is the choice for a **Binary Merkle Tree**, as oposed to Merkle Patricia Trees used in Eth1.\n\nBinary trees provide simplicity and efficiency:\n\n- No irregular branch structures\n- Any data structure can be translated to a binary tree with minimal effort.\n- Less proof witness data in favor of a few more hash operations\n- High affinity with bitfields for navigation and description\n- Enable a wide range of other binary-tree specific optimizations\n\n## Verification\n\nClaims for leaves of data can be verified by reconstructing the root from these leaves with the help of witness data:\nsibling nodes of the branches leading back to the root.\n\n### Multi-proof\n\nA multi-proof is no different than a regular proof other than proving multiple leaf values at the same time.\nNotice that leaf nodes that share the same subtrees also share more witness nodes, and are thus proven together more efficiently.\nSharing of witnesses in general is also more efficient than not sharing, as with individual leaf proofs.\n\n## Proof backings\n\nA \"backing\" is the concept of a specialized binary tree representation that implements the Merkle proof interface,\nand optionally offer additional functionality like proof data lookups or modifications.\n\nFor an implementation, several choices can be made:\n\n- Ordering of leaf nodes and witness data\n- Ordering of operations to reconstruct the root, in case of multi-proofs.\n- Inclusion of a description of the proof target leaves, or the complete proof structure.\n- Optimizations for fast reading, verification or modifications to the proof.\n\nSSZ is agnostic to this: Merkle proofs are an interface to these backings, not an enshrined choice for one approach.","topic":"Merkle_Proofs"},{"data":"# Helper Functions","topic":"Helper_Functions"}]},"__N_SSG":true}