{"pageProps":{"overviewPageData":{"id":"Development","contentHtml":"<div align='center' id='Function'>\n<h1>Development of SSZ</h1>\n<p>Eth2 developers designed SSZ to improve the storage and retrieval of data in the blockchain</p>\n<h3>Function</h3>\n</div>\n<div align='start'>\n<h4><code>Serialize</code>:</h4>\n<ul>\n<li>\n<h5><code>encode data structures as sequences of bytes</code></h5>\n</li>\n</ul>\n<h4><code>Deserialize</code>:</h4>\n<ul>\n<li>\n<h5><code>decode sequences of bytes to reconstruct a given data structure</code></h5>\n</li>\n</ul>\n<h4><code>Merkleize</code>:</h4>\n<ul>\n<li>\n<h5><code>reduce data structure to merkle-root</code></h5>\n</li>\n</ul>\n<h4><code>Validate</code>:</h4>\n<ul>\n<li>\n<h5><code>make proofs and multiproofs for elements in the data structure</code></h5>\n</li>\n</ul>\n</div>\n<div align='center' id='Design'>\n<br/>\n<h3>Design</h3>\n</div>\n<div align='start'>\n<ul>\n<li><strong>Efficiency and Elegance</strong>\n<ul>\n<li>in proof structures with binary trees, and a design that separates opinionated sparse structures from merkleization, learning from issues in ETH 1.0.</li>\n</ul>\n</li>\n<li><strong>Consistency</strong>\n<ul>\n<li>in a wide range of use-cases for minimal and efficient encoding and proofs in the core of ETH 2.0, as well as the layers being built on top.</li>\n</ul>\n</li>\n<li><strong>Flexibility and Transparency</strong>\n<ul>\n<li>for tracing proofs through history, building shallow variants of types, or proofs to linked data such as between ETH 2.0 shards.</li>\n</ul>\n</li>\n<li><strong>Stability of proof data</strong>\n<ul>\n<li>for stateless light clients and smart contracts. These can count on deterministic and stable locations of merkle tree leaves of interest.</li>\n</ul>\n</li>\n<li><strong>Fast data reads</strong>\n<ul>\n<li>by making full deserialization optional, data can be retrieved with a very minimal amount of operations, largely pre-computable at compile time.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div align='center' id='Properties'>\n<h3>Properties</h3>\n</div>\n<div align='start'>\n<ul>\n<li>\n<p><strong>Simple</strong></p>\n<ul>\n<li>SSZ is meant to map well to common raw datatypes, and avoid twiddling with bits or nibbles in serialization.\n<ul>\n<li>It has common basic data types</li>\n<li>It has fixed-length types to avoid unnecessary lengths/offsets</li>\n<li>Types to describe the structure</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li><strong>Bijective</strong>\n<ul>\n<li>No two different representations can exist for the same value of a single type.</li>\n<li>No two different values of the same type can be have the same representation.</li>\n<li>Different types may still have overlapping representations in merkleization or serialization.\n<ul>\n<li>Serialization example:\n<ul>\n<li><code>Vector[uint16, 4]</code>, <code>Vector[uint32, 2]</code>, <code>Vector[uint64, 1]</code>, <code>uint64</code> are all fixed-length and 8 bytes.</li>\n</ul>\n</li>\n<li>Merkleization example:\n<ul>\n<li>A <code>Container</code> with a <code>Vector[uint32, 8]</code> and <code>uint64</code> field has the same merkleization structure as a <code>List[uint64, 4]</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li><strong>Compact</strong>\n<ul>\n<li>Fixed Length Types\n<ul>\n<li>The elements are packed together, and do not result in any extra bytes when used as elements in dynamic types such as lists.</li>\n</ul>\n</li>\n<li>Dynamic types\n<ul>\n<li>4-byte offsets were adopted as a way to enable fast random access of list elements, while keeping the size relatively low. Offsets are only used for dynamic-length element types, whose contents are often significantly bigger than 4 bytes.</li>\n</ul>\n</li>\n<li>Merkleization\n<ul>\n<li>A binary tree backs every merkle structure.</li>\n<li>Since the branching factor is lower than the previously used Merkle Patricia Tree, less nodes are required to reach into a leaf of a merkle tree.</li>\n</ul>\n</li>\n<li>On the application level\n<ul>\n<li>An arbitrary key-value store is avoided, since a <code>List</code> can be packed together better, and have a smaller key depth, thus more efficiency in multi-proofs and avoiding the cost of unbalanced tree shapes.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li><strong>Merkle-first</strong>\n<ul>\n<li>The intention of having a custom type system is also to give anything that can be interpreted by the protocol a sound single generalized <code>merkle-root</code>.</li>\n<li>And not <em>just</em> a <code>merkle-root</code>, but also features that:\n<ul>\n<li>make proofs small,</li>\n<li>avoid complexity in merkleization</li>\n<li>make it as flexible as possible to build and interpret proofs for a data-structure.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>Efficient to traverse</strong></p>\n<ul>\n<li>Efficient traversal is a feature that was later introduced into SSZ with the creation of <a href=\"https://gist.github.com/karalabe/3a25832b1413ee98daad9f0c47be3632\">Simple Offset Serialization (SOS)</a>.\n<ul>\n<li>This guarantees a <code>O(log(N))</code> lookup speed for deeply nested structures. And offsets even enable <code>O(1)</code> random access in lists of dynamic-length elements.</li>\n</ul>\n</li>\n<li>The merkle tree is also efficient for lookups\n<ul>\n<li><a href=\"./overview/generalized_merkle_tree_indices.md\">generalized indices</a> can statically describe the tree node location of any element path.</li>\n<li>This allows any merkle-node lookup to be optimized to a <code>O(log(N))</code> operation where <code>N</code> is the abstract data size (SSZ does not force a uniform data-structure),and where <code>log(N)</code> matches the length of the generalized index.</li>\n<li>And the purely static parts of the path can even be computed at compile time, to improve lookup speeds without writing specialized verbose manual lookup routines.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","title":"SSZ Development","section":"Overview","toc":["Function","Design","Properties"],"prev":"introduction","next":"sszineth2"}},"__N_SSG":true}