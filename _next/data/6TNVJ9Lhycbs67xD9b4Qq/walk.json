{"pageProps":{"markdowns":[{"data":"## Types\n\nData for SSZ Serialization are represented by one or a combination of these **Types:**\n\n- ###### Basic Types: \n  - ###### **Unisigned Integer** -  `Uint8, Uint16, Uint32, Uint64, Uint128, Uint256`\n  - ###### **Boolean** - `Bit, 0 or 1, True or False`\n- ###### Composite Types\n  - ###### **Vector**    - `\"Fixed Length\" sequence of elements of same **Type** (homogeneous)`\n  - ###### **List**    - `\"Variable Length\" sequence of elements of the same **Type** (homogenous)`\n  - ###### **Container**    - `Heterogeneous ordered collection of elements`\n  - ###### **Union**    - `A \"Union Type\" containing SSZ Types`\n  - ###### **Root**    - `A Uint256 that represents the `Bytes32 hash_tree_root` of a nested merkle tree`\n\n\n**Different types *may* merkleize to the same root:**\n\n-  Two values _of different types_ can merkleize to the same `root`\n   - e.g. a `uint256(123)` and `uint8(123)` have the same root.  \n   - Or more exceptionally, a `Container` with 4 `Bytes32` fields can have the same root as a `Vector[uint64, 16]`.\n\n\n##### Default values\n\n\n\nAll SSZ Types have a default \"zeroed\" value\n\n\n\n- `Uint`: 0\n- `Boolean`: False\n- `Vector`: Sequence of default values\n- `List`: Empty List \n- `Container`: Default value for each type in container\n- `Union`: Default value of \"Type_0\"\n  \n\n\n\nDefault values are *recursive*; elements in composite types such as containers are initialized with their respective default initializations\n\n#### `is_zero`\n\nAn SSZ object is called zeroed (and thus, `is_zero(object)` returns true) if it is equal to the default value for that type.\n\n### Illegal types\n\n- Empty vector types (`Vector[type, 0]`, `Bitvector[0]`) are illegal.\n- Containers with no fields are illegal.\n- The `null` type is only legal as the first type in a union subtype (i.e. with type index zero).","topic":"Typing"},{"data":"## Aliases\n\n\n**Types** can be **aliased** to more specific types, good use of type aliasing can make a data-structure much clearer.  \nE.g. \n\n`Gwei = Uint64`  \n`BLSSignature` = `Vector[byte, 96]`  \n`CommitteeBits` = `BitList[limit: MAX_VALIDATORS_PER_COMMITTEE]`  \n`Epoch` = `Uint64`  \n`Root` = `Uint256`  \n`Checkpoint` = `Container[epoch: Epoch, root: Root]`  \n`Bytes32 = Vector[byte, 32]`  \n`Bytes48 = Vector[byte, 48]`  \n`BLSPubkey = Bytes48;`  \n\n**Aliased Types** can be reused to improve readability and consistancy.  \n    \n    Attestation = Container{\n            sourceEpoch: Epoch,\n            targetEpoch: Epoch,\n            signingRoot: Root,\n    }\n\n\n","topic":"Aliases"},{"data":"\n\n# Serialization\n\n\n##### **`SimpleSerialize`** follows simple `byte` conversion, making it effective and efficient for encoding and decoding\n\n##### `Serialization` encodes the data into `Bytes32` chunks for merkleization.\n\n\n\n#### SSZ provides `serialize` and `deserialize` methods for\n\n\n- **Basic types** i.e. integers, Booleans,\n- **List** and *vectors of bits*, known as **BitLists** and **BitVectors**,\n- **Lists** and **Vectors** of `type_serializable`,\n- **Containers** with `type_serializable` *fieds*,\n- **Unions** of `serializable` *types*\n\n\n### \"Type Serializable\"\n\n\nAn object  ***that can be serialized***  is of `type_serializable`\n\n`serializable` can be thought of as a `trait`\n\nGiven a `type T`, we write `T : Serializable` if `T` extends (or \"inherits\" or \"is a\") `Serializable`.\n\n##### Each type `T:Serialiable` should offer two functionalities:\n\n- ###### Serialize:\n  - `serialize<T> : T -> seq<bytes>`\n  - Returns a sequence of bytes when applied to an object of `type T`\n- ###### Deserialize:\n  - `deserialize<T> : seq<bytes> ~-> T`\n  - Returns an object of `type T` *when it is possible* to deserialize a sequence of bytes in an object of `type T`\n\n\n\n\n##### Given two objects `O1:T` and `O2:T` where `T <: Serializable`, the pair of functions (`serialize<T>, deserialize<T>`) should be:\n\n\n\n- **Involutive**: `deserialize<T>( serialize<T>(O1) ) = O1`\n- **Injective**: `serialize<T>(O1) = serialize<T>(O2)` implies that `O1 = O2`\n\n\n\n### Deserialization\n\nBecause serialization is an ***injective*** function \n(i.e. two distinct objects of the same `type` will **`serialize`** to different `values`) \nany `bytestring` has at most one object it could **`deserialize`** to. \n\n\n- Note that deserialization requires hardening against invalid inputs. A non-exhaustive list:\n  - Offsets: out of order, out of range, mismatching minimum element size.\n  - Scope: Extra unused bytes, not aligned with element size.\n  - More elements than a list limit allows. Part of enforcing consensus.","topic":"Serialize_Deserialize"},{"data":"\n\n\n# Merkleization\n\n\n## The Merkle Tree\n\n\n### A **Merkle Tree** is a binary hash tree\n\n- The values of the **Leaves** of the Merkle Tree are each a `Bytes32` result of a `hash function` applied to the serialized objects stored in the tree\n- The value of any **parent** node in the Merkle Tree is the result of the same `hash function` applied to a concatenation of the values of its two **child** nodes.\n- The value of the **Root** node is the culmination of the process of hashing pairs of child nodes to reach a single node.\n  - Referred to in SSZ as `hash_tree_root`\n\n\n**SSZ Merkeleization** aims to provide the following functionality:\n\n\n## `hash_tree_root`\n**`merkleize`** an SSZ object to yield the root.\n\n\nGiven an object `value`, its hash tree root, `hash_tree_root(value)`, is a `BYTES_PER_CHUNK` byte sequence.\n\n\n`BYTES_PER_CHUNK`, 32, is a defined `constant` to represent the number of bytes per chunk. Hence it is equivalent to refer to the output of `hash_tree_root(O)` as being a single chunk.","topic":"Merkleization"},{"data":"\n## Merkle proofs\n\n## For beginners\n\nMerkle proofs enable users to efficiently prove specific details of some data-structure that is known by a given hash.\n\nThe efficiency is achieved with a tree structure of hashes, with the data in the leaves of the tree.\nFor a proof of a set of leaves, branches to other leaves do not have to be fully encoded or hashed,\nthe starts of each such branch, together with the values to proof, are sufficient to reconstruct the root of the tree.\nCompare the reconstructed root with the trusted root the data is known by, and the proof is complete.\n\n## Accumulator\n\nMerkle trees are a type of cryptographic accumulator, and a root is a binding vector commitment to a set of contents.\nI.e. the position of the contents is also committed, not just inclusion. Changing the position of any of the contents would change the Merkle root.\n\nMembership of a leaf value, at a specific position, can be proven with witness data:\na set of hashes along the way to the root of the tree, taking `O(log(N))` space and computation for a proof, as opposed to `N` for providing the full data.\n\n## Binary Merkle Tree\n\nThe tree structure itself affects the amount of nodes, and thus the amount of hash operations, and size of the proof.\n\nOne of the few opinionated choices made by SSZ for Eth2 is the choice for a **Binary Merkle Tree**, as oposed to Merkle Patricia Trees used in Eth1.\n\nBinary trees provide simplicity and efficiency:\n\n- No irregular branch structures\n- Any data structure can be translated to a binary tree with minimal effort.\n- Less proof witness data in favor of a few more hash operations\n- High affinity with bitfields for navigation and description\n- Enable a wide range of other binary-tree specific optimizations\n\n## Verification\n\nClaims for leaves of data can be verified by reconstructing the root from these leaves with the help of witness data:\nsibling nodes of the branches leading back to the root.\n\n### Multi-proof\n\nA multi-proof is no different than a regular proof other than proving multiple leaf values at the same time.\nNotice that leaf nodes that share the same subtrees also share more witness nodes, and are thus proven together more efficiently.\nSharing of witnesses in general is also more efficient than not sharing, as with individual leaf proofs.\n\n### Examples\n\nThe numbers used in below examples are [generalized indices](../navigation/generalized_indices.md), not values.\nNote that the ordering of witness data is an encoding choice, defined by the [proof backing](#proof-backings).\n\n#### Classic single-leaf inclusion proofs\n\n```\n                      1\n          2                       3'\n    4'          5           6           7\n  8    9     10'  11*    12   13     14   15\n```\n\nLeaf: `11`\nWitness data: `10, 4, 3`\nProof: `H(H(4, H(10,11)), 3) == 1`\n\n#### Multiples leaves\n\nAlso called \"multi-proofs\".\n\n```\n                      1\n          2                       3\n    4'          5           6           7'\n  8    9     10*  11*    12'  13*    14   15\n```\n\nLeaves: `10,11,13`\nWitness data: `4, 12, 7`\nProof: `H(H(4, H(10,11)), H(H(12,13), 7)) == 1`\n\n#### Unbalanced trees\n\n```\n              1\n       2              3\n    4    5'        6       7'\n  8' 9*        12     13'\n            24'   25\n                50  51\n           100'101* 102*103*\n```\n\nLeaves: `9,101,102,103`\nWitness data: `8,524,100,13,7`\nProof: `H(H(H(8,9), 5), H(H( H(24, H(H(100,101), H(102, 103))), 13), 7)) == 1`\n\n## Proof backings\n\nA \"backing\" is the concept of a specialized binary tree representation that implements the Merkle proof interface,\nand optionally offer additional functionality like proof data lookups or modifications.\n\nFor an implementation, several choices can be made:\n\n- Ordering of leaf nodes and witness data\n- Ordering of operations to reconstruct the root, in case of multi-proofs.\n- Inclusion of a description of the proof target leaves, or the complete proof structure.\n- Optimizations for fast reading, verification or modifications to the proof.\n\nSSZ is agnostic to this: Merkle proofs are an interface to these backings, not an enshrined choice for one approach.\n\n## Interface\n\nFor application level usage, describing the proof with a typed structure is recommended, see [SSZ partials](../partials).\n\nFor lower level usage, most of the complexity (and implementation freedom) is transferred to the underlying proof backing, and only a bare minimum interface is defined:\n\n`compute_root(proof_backing) -> root`\n\n`verify(proof_backing, root) -> bool: return compute_root(proof_backing) == root`\n","topic":"Merkle_Proofs"},{"data":"## Summaries and expansions\n\nLet `A` be an object derived from another object `B` by replacing some of the (possibly nested) values of `B` by their `hash_tree_root`. We say `A` is a \"summary\" of `B`, and that `B` is an \"expansion\" of `A`. Notice `hash_tree_root(A) == hash_tree_root(B)`.\n\nWe similarly define \"summary types\" and \"expansion types\". For example, [`BeaconBlock`](../specs/phase0/beacon-chain.md#beaconblock) is an expansion type of [`BeaconBlockHeader`](../specs/phase0/beacon-chain.md#beaconblockheader). Notice that objects expand to at most one object of a given expansion type. For example, `BeaconBlockHeader` objects uniquely expand to `BeaconBlock` objects.","topic":"Summaries_and_Expansions"}]},"__N_SSG":true}