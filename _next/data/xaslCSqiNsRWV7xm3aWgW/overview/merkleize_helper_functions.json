{"pageProps":{"overviewPageData":{"id":"merkleize_helper_functions","contentHtml":"<div align='center'>\n<h1>Merkelize Helper Functions:</h1>\n</div>\n<div align='start' id='merkleize_helper_function' >\n<ul>\n<li><a href=\"#size_of\">size_of</a></li>\n<li><a href=\"#chunk_count\">chunk_count</a></li>\n<li><a href=\"#pack\">pack</a></li>\n<li><a href=\"#pack_bits\">pack_bits</a></li>\n<li><a href=\"#next_pow_of_two\">next_pow_of_two</a></li>\n<li><a href=\"#merkleize\">merkleize</a></li>\n<li><a href=\"#mix_in_length\">mix_in_length</a></li>\n<li><a href=\"#mix_in_type\">mix_in_type</a></li>\n</ul>\n</div>\n<div id='size_of'>\n</div>\n<h2>size_of</h2>\n<pre><code>size_of(B), where B is a basic type: the length, in bytes, of the serialized form of the basic type.\n</code></pre>\n<p>As this function is only applicable to a basic type, the input must be a uintN or boolean.</p>\n<p>The output must be the length, in bytes, of the serialized form of the basic type. Thus the function must return a minimum of 1 byte (i.e. for boolean and uint8) and a maximum of 32 bytes (i.e. for a uint256). 1 &#x3C;= size_of(B) &#x3C;= 32 therefore represents a post-condition of the function.</p>\n<div id='chunk_count' >\n</div>\n<h2>chunk_count</h2>\n<pre><code>    chunk_count(type): calculate the amount of leafs for merkleization of the type.\n</code></pre>\n<ul>\n<li>all basic types: 1</li>\n<li>Bitlist[N] and Bitvector[N]: (N + 255) // 256 (dividing by chunk size, rounding up)</li>\n<li>List[B, N] and Vector[B, N], where B is a basic type: (N * size_of(B) + 31) // 32 (dividing by chunk size, rounding up)</li>\n<li>List[C, N] and Vector[C, N], where C is a composite type: N</li>\n<li>containers: len(fields)</li>\n</ul>\n<p>Intended to represent the amount of leaves for merkleization of the type.</p>\n<p>The <code>chunk_count</code> function is related to both the <code>pack</code> and <code>pack</code>_bits functions. For basic types, or lists or vectors of basic types, the number of chunks returned by chunk_count should equal the number of chunks returned by the <code>pack</code> function. This includes for an empty list i.e. <code>list[B, N=0]</code>.</p>\n<p>For bitvectors and bitlists, the number of chunks returned by chunk_count should equal the number of chunks returned by the <code>pack_bits</code> function, again this will be true even for an empty bitlist i.e. bitlist[N=0].</p>\n<p>For these types, that <code>len(pack(value)) = chunk_count(type)</code> or <code>len(pack_bits(value)) = chunk_count(type)</code> can be seen as an additional post-condition to the chunk_count function or as a property relating the functions</p>\n<div id='pack' >\n</div>\n<h2>pack</h2>\n<p><code>pack(values)</code>: Given ordered objects of the same basic type:</p>\n<ol>\n<li>\n<p>Serialize <code>values</code> into bytes.</p>\n</li>\n<li>\n<p>If not aligned to a multiple of <code>BYTES_PER_CHUNK</code> bytes, right-pad with zeroes to the next multiple.</p>\n</li>\n<li>\n<p>Partition the bytes into <code>BYTES_PER_CHUNK</code>-byte chunks.</p>\n</li>\n<li>\n<p>Return the chunks.</p>\n</li>\n</ol>\n<p>This function is designed to create the chunks required to merkleize a <code>value</code> that is either a basic type, a vector of basic objects or a list of basic objects. The scope of type for the <code>value</code> parameter represents a function pre-condition.</p>\n<p>The <code>values</code> (i.e. the plural form includes the case of a single basic type, as well as the possibility of an empty sequence in the case of a list) are firstly serialized and then if the number of resulting bytes is not a multiple of 32 then the output is right padded with zero bytes to ensure a multiple of 32 bytes.</p>\n<p>Note that if we are dealing with an empty list then its serialized form will be zero bytes. Because zero is a multiple of 32 in this case no padding is required and zero chunks will be returned by the <code>pack</code> function. This outcome is consistent with the intention discussed within the explanation of the chunk_count function.</p>\n<p>The final step of the <code>pack</code> function is to partition the serialized and padded bytes into 32 byte chunks.</p>\n<p>The output of the <code>pack</code> function is therefore a series of 32 byte chunks and we can observe the following post-conditions:</p>\n<pre><code>0 &#x3C;= len(pack(values))\nlen(pack(values)) == chunk_count(type)\n</code></pre>\n<div id='pack_bits' >\n</div>\n<h2>pack_bits</h2>\n<p><code>pack_bits(bits)</code></p>\n<blockquote>\n<ul>\n<li>Given the bits of bitlist or bitvector, get bitfield_bytes by packing them in bytes and aligning to the start.</li>\n<li>The length-delimiting bit for bitlists is excluded.</li>\n<li>Then return <code>pack(bitfield_bytes)</code></li>\n</ul>\n</blockquote>\n<p>The <code>pack_bits</code> function is analogous to the <code>pack</code> function with the output being a series of 32 byte chunks that willget used in the merkleization process.</p>\n<p>In this case the input comprises the bits of a <code>bitvector</code> or <code>bitlist</code>. It can be distinguished from the <code>pack</code> function because the bits get packed into bytes with no delimiting bit; noting that when a <code>bitlist</code> is serialized the bits are also packed into bytes but a delimitng bit is appended. It is therefore almost the same as the <code>pack</code> function but in the case of a <code>bitlist</code>, the serialization differs to exclude the use of a delimiting bit.</p>\n<p>The bytes generated are referred to as <code>bitfield_bytes</code> and then this series of bytes (i.e. a series of <code>uint8</code>s) become the input of <code>pack</code> to complete the generation of the chunk output. Note that as the input to <code>pack</code> in this context is a series of uint8s, the first step of the <code>pack</code> function, which is to serialise the values, is redundant because serialisation of a series of uint8s will leave the bytes unchanged. The main purpose of returning <code>pack(bitfield_bytes)</code> is to ensure that a multiple of 32 bytes is generated, using padding if needed, and then that these bytes are partitioned into the 32 byte chunks that form the ultimate output.</p>\n<p>The pre-condition of the <code>pack_bits</code> function is thus that the bits are the bits of a <code>bitvector</code> or <code>bitlist</code>.</p>\n<p>The post-conditions of the <code>pack_bits</code> are the same as for the <code>pack</code> function:</p>\n<pre><code>0 &#x3C;= len(pack(values))\nlen(pack(values)) == chunk_count(type)\n</code></pre>\n<div id='next_pow_of_two' >\n</div>\n<h2>next_pow_of_two</h2>\n<p><code>next_pow_of_two(i)</code>:</p>\n<blockquote>\n<ul>\n<li>Get the next power of 2 of i, if not already a power of 2, with 0 mapping to 1.\n<ul>\n<li>Examples: 0->1, 1->1, 2->2, 3->4, 4->4, 6->8, 9->16</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The next_pow_of_two function is a helper function for the merkleize function and is used to ensure that the number of leaves being merkleised is a power of 2.</p>\n<p>A relatively straight forward mathematical helper function it is important to make sure that an input of zero maps to an output of 1.</p>\n<p>Hence the next_pow_of_two(i) function has the following pre-condition:</p>\n<pre><code>0 &#x3C;= i\n</code></pre>\n<p>and the following post-conditions and properties:</p>\n<pre><code>1 &#x3C;= next_pow_of_two(i)\nnext_pow_of_two(i) == next_pow_of_two(next_pow_of_two(i))\nis_power2(next_pow_of_two(i)) == true\n</code></pre>\n<div id='merkleize' >\n</div>\n<h2>merkleize</h2>\n<p><code>merkleize(chunks, limit=None)</code></p>\n<blockquote>\n<ul>\n<li>Given ordered BYTES_PER_CHUNK-byte chunks, merkleize the chunks, and return the root:</li>\n<li>The merkleization depends on the effective input, which must be padded/limited:\n<ul>\n<li>if no limit: pad the chunks with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency).</li>\n<li>if limit >= len(chunks), pad the chunks with zeroed chunks to next_pow_of_two(limit) (virtually for memory efficiency).</li>\n<li>if limit &#x3C; len(chunks): do not merkleize, input exceeds limit. Raise an error instead.</li>\n</ul>\n</li>\n<li>Then, merkleize the chunks (empty input is padded to 1 zero chunk):\n<ul>\n<li>If 1 chunk: the root is the chunk itself.</li>\n<li>If > 1 chunks: merkleize as binary tree.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The merkleize function takes a series of 32 byte chunks and a limit parameter.</p>\n<p>The chunks are used to form the leaves of a binary merkle tree and the function returns the root of that tree. Note that len(chunks) >= 0 and hence as the chunks will form the leaves of the binary tree, chunk padding may need to be implemented to ensure that the number of leaves is a power of 2. Which power of 2 depends on the limit parameter. If there is no limit then we simply pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). If limit >= len(chunks) then we pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). And if neither of these cases apply then we have a situation where something has gone wrong and the limit &#x3C; len(chunks); in which case an error should be raised.</p>\n<p>The limit parameter has a default value of None but is generally set to chunk_count(type) where the value being processed is a variable length type such as a list or a bitlist. The use of something other than the default is to ensure that sufficient leaves are created to allow for the maximum length of that type, regardless of its current length. I say generally in the context of it being used for variable length types because limit=chunk_count(type) also appears for a bitvector; though in this case the use of the limit is redundant because a bitvector is a fixed length type and so that is no need for the provision of additional leaves; it can be seen that len(chunks) == chunk_count(type).</p>\n<p>At this point in the processing the number of chunks, i.e. leaves, is a power of 2 and we are ready to create the binary merkle tree. Because of the chunk padding rule we should note that there will be a minimum of 1 chunk. For example, even if zero chunks were sent into the merkleize function (e.g. as in the case of a list[B,0]) because next_pow_of_two(0) == 1 we will have 1 chunk after padding. Hence it should be noted that the second step of this function, namely Then, merkleize the chunks (empty input is padded to 1 zero chunk) includes some redundancy as empty input can not occur at this stage in the processing.</p>\n<p>This second step completes the processing: if we have 1 chunk then that is the root and can be returned, if we have more than 1 chunk then we implement merkelization as a binary tree.</p>\n<div id='mix_in_length' >\n</div>\n<h2>mix_in_length</h2>\n<p><code>mix_in_length</code>:</p>\n<blockquote>\n<ul>\n<li>Given a Merkle root <code>root</code> and a length <code>length</code> (<code>uint256</code> little-endian serialization) return <code>hash(root + length)</code></li>\n</ul>\n</blockquote>\n<p>This function is used for variable length types i.e. where the length of the value may be less than the maximum specified. The maximum is encoded into the binary merkle tree be the provision of sufficient leaves to store a value of this maximum length, however the actual length must also be represented and is done so through the <code>mix_in_length</code> function. The merkle root generated from the merkleize function is concatenated with the actual length (i.e. where length is represented as a <code>uint256</code> using little-endian serialization) and then hashed.</p>\n<div id='mix_in_type' >\n</div>\n<h2>mix_in_type</h2>\n<p><code>mix_in_type</code></p>\n<blockquote>\n<ul>\n<li>Given a Merkle root <code>root</code> and a type_index <code>type_index</code> (<code>uint256</code> little-endian serialization) return <code>hash(root + type_index)</code></li>\n<li>This function is used for Union types</li>\n</ul>\n</blockquote>\n","title":"Merkleize Helper Functions","toc":["merkleize_helper_function","size_of","chunk_count","pack","pack_bits","next_pow_of_two","merkleize","mix_in_length","mix_in_type"],"prev":"Merkleize","next":"hash_tree_root"}},"__N_SSG":true}