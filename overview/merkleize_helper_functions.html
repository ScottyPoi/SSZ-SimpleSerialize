<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous"/><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><link rel="stylesheet" data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/78e95eee04922cdbbcf6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/78e95eee04922cdbbcf6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f34f79b5fc3b3ec3ac62.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f34f79b5fc3b3ec3ac62.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a28103e196b8ae4e74f1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a28103e196b8ae4e74f1.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-092815d009f02b961512.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-5ca6b2fc774362eae352.js" as="script"/><link rel="preload" href="/_next/static/chunks/679-5da5ce082708612ab660.js" as="script"/><link rel="preload" href="/_next/static/chunks/778-f7da0898f16776c961fa.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-b585fbee1813a2c23693.js" as="script"/><link rel="preload" href="/_next/static/chunks/723-7930b78c5f6cd3b643bb.js" as="script"/><link rel="preload" href="/_next/static/chunks/168-cab4f03cc2887b280c77.js" as="script"/><link rel="preload" href="/_next/static/chunks/549-f4b5e9dc3df62febb2ea.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-239eacba429f2e007d2e.js" as="script"/><link rel="preload" href="/_next/static/chunks/986-f8942b1674516fcd3903.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/overview/%5Bid%5D-10591d769e17fd787eaf.js" as="script"/><style data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><style data-emotion="css-global 1v5hfar">html,body{padding:3rem 1rem;margin:0;min-height:100%;background-color:rgb(20,20,20);color:rgb(200,200,200);font-family:sans-serif;font-size:1rem;}a{color:white;-webkit-text-decoration:none;text-decoration:none;}code{color:white;}text{color:rbg(200, 200, 250);}section{padding:1rem;}h1{color:rgb(250,250,250);}h2{color:rgb(220,220,230);}h3{color:rgb(210,210,230);}h4{color:rgb(190,190,220);}h5{color:rgb(190,190,195);}h6{color:rgb(200,200,220);}p{color:rgb(210,210,240);}li{color:rgb(220,220,230);}td{color:white;}th{color:rgb(50,100,250);}</style><div class="container"><div class="d-flex"><div class="row fixed-top "><div class="col"><div class="row"><div class="container-fluid"><nav class="navbar navbar-expand-lg navbar-dark bg-dark" collapseonselect="true" expand="lg" bg="dark" variant="dark"><div class="row"><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavDropdown"><a class="navbar-brand" href="./">SSZ</a><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" href="/">Home</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Documentation" aria-expanded="false">Documentation</a><ul class="dropdown-menu" aria-labelledby="Documentation"><li><a href="/specs"> <!-- -->Specs</a></li><li><a href="/merkle-proofs"> <!-- -->Merkle Proofs</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Overview" aria-expanded="false">Overview</a><ul class="dropdown-menu" aria-labelledby="Overview"><li><a href="/overview/overview"> <!-- -->Introduction</a></li><li><a href="/overview/Typing"> <!-- -->Typing</a></li><li><a href="/overview/Serialization"> <!-- -->Serialization</a></li><li><a href="/overview/Deserialization"> <!-- -->Deserialization</a></li><li><a href="/overview/Merkleization"> <!-- -->Merkleization</a></li><li><a href="/overview/merkle"> <!-- -->Merkle Proofs</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Implementations" aria-expanded="false">Implementations</a><ul class="dropdown-menu" aria-labelledby="Implementations"><li><a href="/implementations/python"> <!-- -->Python</a></li><li><a href="/implementations/typescript"> <!-- -->TypeScript</a></li><li><a href="/implementations/go"> <!-- -->Go</a></li><li><a href="/implementations/dafny"> <!-- -->Dafny</a></li><li><a href="/implementations/java"> <!-- -->Java</a></li><li><a href="/implementations/nim"> <!-- -->Nim</a></li><li><a href="/implementations/csharp"> <!-- -->C#</a></li><li><a href="/implementations/zig"> <!-- -->Zig</a></li><li><a href="/implementations/rust"> <!-- -->Rust</a></li><li><a href="/implementations/swift"> <!-- -->Swift</a></li></ul></li><a href="https://github.com/scottypoi/ssz-simpleserialize" style="position:absolute;right:0;top:0"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_orange_ff7600.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"/></a></ul></div></div></nav></div></div></div></div><div class="container"><div class="d-flex row justify-content-between position-relative d-none d-sm-block"><div class="col-2 justify-content-start position-fixed top-10 start-0 " style="z-index:1"><nav class="nav align-items-stretch"><div><div class="nav flex-column nav-expand-lg" id="navbarSupportedContent"><div class="row justify-content-center">Site Map</div><div class="row "><div class="d-flex flex-column  navbar-nav-scroll NavBar_nonavbar__mWkf4" style="scrollbar-width:0"><ul class="navbar-nav"><div class="d-flex flex-row"><li><a class="NavBar_sitemap1__3yDNX" href="/">Home</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap1__3yDNX" href="/documentation">Documentation</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/specs">Specs</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/merkle-proofs">Merkle Proofs</a></li></div></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap1__3yDNX" href="/overview/overview">Overview</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/overview"> <!-- -->Introduction<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Development"> <!-- -->Development<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/sszineth2"> <!-- -->SSZ in Eth2<!-- --> </a></li></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/Typing"> <!-- -->Typing<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/basic"> <!-- -->Basic Types<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Composite_Types"> <!-- -->Composite Types<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/bitfields"> <!-- -->Bitfields<!-- --> </a></li></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/Serialization"> <!-- -->Serialization<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Simple_Objects"> <!-- -->Simple Objects<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Composite_Objects"> <!-- -->Composite Objects<!-- --> </a></li></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/Deserialization"> <!-- -->Deserialization<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Fixed_Size_Objects"> <!-- -->Fixed-Size Objects<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/Variable_Size_Objects"> <!-- -->Variable-Size Objects<!-- --> </a></li></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/Merkleization"> <!-- -->Merkleization<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/hashing"> <!-- -->Hashing<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/chunking"> <!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/merkleize"> <!-- -->Merkleize<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/merkleize_helper_functions"> <!-- -->Merkleize Helper Functions<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/hash_tree_root"> <!-- -->hash_tree_root<!-- --> </a></li></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/overview/merkle"> <!-- -->Merkle Proofs<!-- --> </a><ul class="navbar-nav"><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/merkle_proof_helper_functions"> <!-- -->Helper Functions<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/generalized_indices"> <!-- -->Generalized Merkle Tree Indices<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/ssz_object_to_index"> <!-- -->SSZ object to index<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/helpers_for_generalized_indices"> <!-- -->Helpers for generalized_indices<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/merkle_multiproofs"> <!-- -->Merkle Multiproofs<!-- --> </a></li><li class="d-flex flex-row"><a class="NavBar_sitemap3__2hayE" href="/overview/summaries_expansions"> <!-- -->Summaries and Expansions<!-- --> </a></li></ul></li></div></ul></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap1__3yDNX" href="/implementations/home">Implementations</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/python">Python</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/typescript">TypeScript</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/go">Go</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/dafny">Dafny</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/java">Java</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/nim">Nim</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/csharp">C#</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/zig">Zig</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/rust">Rust</a></li></div><div class="d-flex flex-row"><li><a class="NavBar_sitemap2__iCMGQ" href="/implementations/swift">Swift</a></li></div></ul></li></div></ul></div></div></div></div></nav></div></div><div class="d-flex row position-static justify-content-xs-start justify-content-sm-around"><div class="col-12 col-sm-10" style="z-index:0"><div class="container"><div class="row justify-content-center"><div class="col-12 col-sm-10"><div align='center'>
<h1>Merkelize Helper Functions:</h1>
</div>
<div align='start' id='merkleize_helper_function' >
<ul>
<li><a href="#size_of">size_of</a></li>
<li><a href="#chunk_count">chunk_count</a></li>
<li><a href="#pack">pack</a></li>
<li><a href="#pack_bits">pack_bits</a></li>
<li><a href="#next_pow_of_two">next_pow_of_two</a></li>
<li><a href="#merkleize">merkleize</a></li>
<li><a href="#mix_in_length">mix_in_length</a></li>
<li><a href="#mix_in_type">mix_in_type</a></li>
</ul>
</div>
<div id='size_of'>
</div>
<h2>size_of</h2>
<pre><code>size_of(B), where B is a basic type: the length, in bytes, of the serialized form of the basic type.
</code></pre>
<p>As this function is only applicable to a basic type, the input must be a uintN or boolean.</p>
<p>The output must be the length, in bytes, of the serialized form of the basic type. Thus the function must return a minimum of 1 byte (i.e. for boolean and uint8) and a maximum of 32 bytes (i.e. for a uint256). 1 &#x3C;= size_of(B) &#x3C;= 32 therefore represents a post-condition of the function.</p>
<div id='chunk_count' >
</div>
<h2>chunk_count</h2>
<pre><code>    chunk_count(type): calculate the amount of leafs for merkleization of the type.
</code></pre>
<ul>
<li>all basic types: 1</li>
<li>Bitlist[N] and Bitvector[N]: (N + 255) // 256 (dividing by chunk size, rounding up)</li>
<li>List[B, N] and Vector[B, N], where B is a basic type: (N * size_of(B) + 31) // 32 (dividing by chunk size, rounding up)</li>
<li>List[C, N] and Vector[C, N], where C is a composite type: N</li>
<li>containers: len(fields)</li>
</ul>
<p>Intended to represent the amount of leaves for merkleization of the type.</p>
<p>The <code>chunk_count</code> function is related to both the <code>pack</code> and <code>pack</code>_bits functions. For basic types, or lists or vectors of basic types, the number of chunks returned by chunk_count should equal the number of chunks returned by the <code>pack</code> function. This includes for an empty list i.e. <code>list[B, N=0]</code>.</p>
<p>For bitvectors and bitlists, the number of chunks returned by chunk_count should equal the number of chunks returned by the <code>pack_bits</code> function, again this will be true even for an empty bitlist i.e. bitlist[N=0].</p>
<p>For these types, that <code>len(pack(value)) = chunk_count(type)</code> or <code>len(pack_bits(value)) = chunk_count(type)</code> can be seen as an additional post-condition to the chunk_count function or as a property relating the functions</p>
<div id='pack' >
</div>
<h2>pack</h2>
<p><code>pack(values)</code>: Given ordered objects of the same basic type:</p>
<ol>
<li>
<p>Serialize <code>values</code> into bytes.</p>
</li>
<li>
<p>If not aligned to a multiple of <code>BYTES_PER_CHUNK</code> bytes, right-pad with zeroes to the next multiple.</p>
</li>
<li>
<p>Partition the bytes into <code>BYTES_PER_CHUNK</code>-byte chunks.</p>
</li>
<li>
<p>Return the chunks.</p>
</li>
</ol>
<p>This function is designed to create the chunks required to merkleize a <code>value</code> that is either a basic type, a vector of basic objects or a list of basic objects. The scope of type for the <code>value</code> parameter represents a function pre-condition.</p>
<p>The <code>values</code> (i.e. the plural form includes the case of a single basic type, as well as the possibility of an empty sequence in the case of a list) are firstly serialized and then if the number of resulting bytes is not a multiple of 32 then the output is right padded with zero bytes to ensure a multiple of 32 bytes.</p>
<p>Note that if we are dealing with an empty list then its serialized form will be zero bytes. Because zero is a multiple of 32 in this case no padding is required and zero chunks will be returned by the <code>pack</code> function. This outcome is consistent with the intention discussed within the explanation of the chunk_count function.</p>
<p>The final step of the <code>pack</code> function is to partition the serialized and padded bytes into 32 byte chunks.</p>
<p>The output of the <code>pack</code> function is therefore a series of 32 byte chunks and we can observe the following post-conditions:</p>
<pre><code>0 &#x3C;= len(pack(values))
len(pack(values)) == chunk_count(type)
</code></pre>
<div id='pack_bits' >
</div>
<h2>pack_bits</h2>
<p><code>pack_bits(bits)</code></p>
<blockquote>
<ul>
<li>Given the bits of bitlist or bitvector, get bitfield_bytes by packing them in bytes and aligning to the start.</li>
<li>The length-delimiting bit for bitlists is excluded.</li>
<li>Then return <code>pack(bitfield_bytes)</code></li>
</ul>
</blockquote>
<p>The <code>pack_bits</code> function is analogous to the <code>pack</code> function with the output being a series of 32 byte chunks that willget used in the merkleization process.</p>
<p>In this case the input comprises the bits of a <code>bitvector</code> or <code>bitlist</code>. It can be distinguished from the <code>pack</code> function because the bits get packed into bytes with no delimiting bit; noting that when a <code>bitlist</code> is serialized the bits are also packed into bytes but a delimitng bit is appended. It is therefore almost the same as the <code>pack</code> function but in the case of a <code>bitlist</code>, the serialization differs to exclude the use of a delimiting bit.</p>
<p>The bytes generated are referred to as <code>bitfield_bytes</code> and then this series of bytes (i.e. a series of <code>uint8</code>s) become the input of <code>pack</code> to complete the generation of the chunk output. Note that as the input to <code>pack</code> in this context is a series of uint8s, the first step of the <code>pack</code> function, which is to serialise the values, is redundant because serialisation of a series of uint8s will leave the bytes unchanged. The main purpose of returning <code>pack(bitfield_bytes)</code> is to ensure that a multiple of 32 bytes is generated, using padding if needed, and then that these bytes are partitioned into the 32 byte chunks that form the ultimate output.</p>
<p>The pre-condition of the <code>pack_bits</code> function is thus that the bits are the bits of a <code>bitvector</code> or <code>bitlist</code>.</p>
<p>The post-conditions of the <code>pack_bits</code> are the same as for the <code>pack</code> function:</p>
<pre><code>0 &#x3C;= len(pack(values))
len(pack(values)) == chunk_count(type)
</code></pre>
<div id='next_pow_of_two' >
</div>
<h2>next_pow_of_two</h2>
<p><code>next_pow_of_two(i)</code>:</p>
<blockquote>
<ul>
<li>Get the next power of 2 of i, if not already a power of 2, with 0 mapping to 1.
<ul>
<li>Examples: 0->1, 1->1, 2->2, 3->4, 4->4, 6->8, 9->16</li>
</ul>
</li>
</ul>
</blockquote>
<p>The next_pow_of_two function is a helper function for the merkleize function and is used to ensure that the number of leaves being merkleised is a power of 2.</p>
<p>A relatively straight forward mathematical helper function it is important to make sure that an input of zero maps to an output of 1.</p>
<p>Hence the next_pow_of_two(i) function has the following pre-condition:</p>
<pre><code>0 &#x3C;= i
</code></pre>
<p>and the following post-conditions and properties:</p>
<pre><code>1 &#x3C;= next_pow_of_two(i)
next_pow_of_two(i) == next_pow_of_two(next_pow_of_two(i))
is_power2(next_pow_of_two(i)) == true
</code></pre>
<div id='merkleize' >
</div>
<h2>merkleize</h2>
<p><code>merkleize(chunks, limit=None)</code></p>
<blockquote>
<ul>
<li>Given ordered BYTES_PER_CHUNK-byte chunks, merkleize the chunks, and return the root:</li>
<li>The merkleization depends on the effective input, which must be padded/limited:
<ul>
<li>if no limit: pad the chunks with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency).</li>
<li>if limit >= len(chunks), pad the chunks with zeroed chunks to next_pow_of_two(limit) (virtually for memory efficiency).</li>
<li>if limit &#x3C; len(chunks): do not merkleize, input exceeds limit. Raise an error instead.</li>
</ul>
</li>
<li>Then, merkleize the chunks (empty input is padded to 1 zero chunk):
<ul>
<li>If 1 chunk: the root is the chunk itself.</li>
<li>If > 1 chunks: merkleize as binary tree.</li>
</ul>
</li>
</ul>
</blockquote>
<p>The merkleize function takes a series of 32 byte chunks and a limit parameter.</p>
<p>The chunks are used to form the leaves of a binary merkle tree and the function returns the root of that tree. Note that len(chunks) >= 0 and hence as the chunks will form the leaves of the binary tree, chunk padding may need to be implemented to ensure that the number of leaves is a power of 2. Which power of 2 depends on the limit parameter. If there is no limit then we simply pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). If limit >= len(chunks) then we pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). And if neither of these cases apply then we have a situation where something has gone wrong and the limit &#x3C; len(chunks); in which case an error should be raised.</p>
<p>The limit parameter has a default value of None but is generally set to chunk_count(type) where the value being processed is a variable length type such as a list or a bitlist. The use of something other than the default is to ensure that sufficient leaves are created to allow for the maximum length of that type, regardless of its current length. I say generally in the context of it being used for variable length types because limit=chunk_count(type) also appears for a bitvector; though in this case the use of the limit is redundant because a bitvector is a fixed length type and so that is no need for the provision of additional leaves; it can be seen that len(chunks) == chunk_count(type).</p>
<p>At this point in the processing the number of chunks, i.e. leaves, is a power of 2 and we are ready to create the binary merkle tree. Because of the chunk padding rule we should note that there will be a minimum of 1 chunk. For example, even if zero chunks were sent into the merkleize function (e.g. as in the case of a list[B,0]) because next_pow_of_two(0) == 1 we will have 1 chunk after padding. Hence it should be noted that the second step of this function, namely Then, merkleize the chunks (empty input is padded to 1 zero chunk) includes some redundancy as empty input can not occur at this stage in the processing.</p>
<p>This second step completes the processing: if we have 1 chunk then that is the root and can be returned, if we have more than 1 chunk then we implement merkelization as a binary tree.</p>
<div id='mix_in_length' >
</div>
<h2>mix_in_length</h2>
<p><code>mix_in_length</code>:</p>
<blockquote>
<ul>
<li>Given a Merkle root <code>root</code> and a length <code>length</code> (<code>uint256</code> little-endian serialization) return <code>hash(root + length)</code></li>
</ul>
</blockquote>
<p>This function is used for variable length types i.e. where the length of the value may be less than the maximum specified. The maximum is encoded into the binary merkle tree be the provision of sufficient leaves to store a value of this maximum length, however the actual length must also be represented and is done so through the <code>mix_in_length</code> function. The merkle root generated from the merkleize function is concatenated with the actual length (i.e. where length is represented as a <code>uint256</code> using little-endian serialization) and then hashed.</p>
<div id='mix_in_type' >
</div>
<h2>mix_in_type</h2>
<p><code>mix_in_type</code></p>
<blockquote>
<ul>
<li>Given a Merkle root <code>root</code> and a type_index <code>type_index</code> (<code>uint256</code> little-endian serialization) return <code>hash(root + type_index)</code></li>
<li>This function is used for Union types</li>
</ul>
</blockquote>
</div></div><div class="row justify-content-between"><div class="col-2"><a href="Merkleize">Previous</a></div><div class="col-2"><a href="hash_tree_root">Next</a></div></div><div class="d-flex row justify-content-end position-fixed fixed-top"><div class="col-2"><br/><br/><br/><br/><div class="row d-none d-sm-block"><div class="nav flex-column"><ul><ul class=""><li class=""><a href="merkleize_helper_functions#merkleize_helper_function">merkleize_helper_function</a></li><li class=""><a href="merkleize_helper_functions#size_of">size_of</a></li><li class=""><a href="merkleize_helper_functions#chunk_count">chunk_count</a></li><li class=""><a href="merkleize_helper_functions#pack">pack</a></li><li class=""><a href="merkleize_helper_functions#pack_bits">pack_bits</a></li><li class=""><a href="merkleize_helper_functions#next_pow_of_two">next_pow_of_two</a></li><li class=""><a href="merkleize_helper_functions#merkleize">merkleize</a></li><li class=""><a href="merkleize_helper_functions#mix_in_length">mix_in_length</a></li><li class=""><a href="merkleize_helper_functions#mix_in_type">mix_in_type</a></li></ul></ul></div></div></div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"overviewPageData":{"id":"merkleize_helper_functions","contentHtml":"\u003cdiv align='center'\u003e\n\u003ch1\u003eMerkelize Helper Functions:\u003c/h1\u003e\n\u003c/div\u003e\n\u003cdiv align='start' id='merkleize_helper_function' \u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#size_of\"\u003esize_of\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#chunk_count\"\u003echunk_count\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pack\"\u003epack\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#pack_bits\"\u003epack_bits\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#next_pow_of_two\"\u003enext_pow_of_two\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#merkleize\"\u003emerkleize\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mix_in_length\"\u003emix_in_length\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mix_in_type\"\u003emix_in_type\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003cdiv id='size_of'\u003e\n\u003c/div\u003e\n\u003ch2\u003esize_of\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003esize_of(B), where B is a basic type: the length, in bytes, of the serialized form of the basic type.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs this function is only applicable to a basic type, the input must be a uintN or boolean.\u003c/p\u003e\n\u003cp\u003eThe output must be the length, in bytes, of the serialized form of the basic type. Thus the function must return a minimum of 1 byte (i.e. for boolean and uint8) and a maximum of 32 bytes (i.e. for a uint256). 1 \u0026#x3C;= size_of(B) \u0026#x3C;= 32 therefore represents a post-condition of the function.\u003c/p\u003e\n\u003cdiv id='chunk_count' \u003e\n\u003c/div\u003e\n\u003ch2\u003echunk_count\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e    chunk_count(type): calculate the amount of leafs for merkleization of the type.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eall basic types: 1\u003c/li\u003e\n\u003cli\u003eBitlist[N] and Bitvector[N]: (N + 255) // 256 (dividing by chunk size, rounding up)\u003c/li\u003e\n\u003cli\u003eList[B, N] and Vector[B, N], where B is a basic type: (N * size_of(B) + 31) // 32 (dividing by chunk size, rounding up)\u003c/li\u003e\n\u003cli\u003eList[C, N] and Vector[C, N], where C is a composite type: N\u003c/li\u003e\n\u003cli\u003econtainers: len(fields)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIntended to represent the amount of leaves for merkleization of the type.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003echunk_count\u003c/code\u003e function is related to both the \u003ccode\u003epack\u003c/code\u003e and \u003ccode\u003epack\u003c/code\u003e_bits functions. For basic types, or lists or vectors of basic types, the number of chunks returned by chunk_count should equal the number of chunks returned by the \u003ccode\u003epack\u003c/code\u003e function. This includes for an empty list i.e. \u003ccode\u003elist[B, N=0]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor bitvectors and bitlists, the number of chunks returned by chunk_count should equal the number of chunks returned by the \u003ccode\u003epack_bits\u003c/code\u003e function, again this will be true even for an empty bitlist i.e. bitlist[N=0].\u003c/p\u003e\n\u003cp\u003eFor these types, that \u003ccode\u003elen(pack(value)) = chunk_count(type)\u003c/code\u003e or \u003ccode\u003elen(pack_bits(value)) = chunk_count(type)\u003c/code\u003e can be seen as an additional post-condition to the chunk_count function or as a property relating the functions\u003c/p\u003e\n\u003cdiv id='pack' \u003e\n\u003c/div\u003e\n\u003ch2\u003epack\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epack(values)\u003c/code\u003e: Given ordered objects of the same basic type:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eSerialize \u003ccode\u003evalues\u003c/code\u003e into bytes.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf not aligned to a multiple of \u003ccode\u003eBYTES_PER_CHUNK\u003c/code\u003e bytes, right-pad with zeroes to the next multiple.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePartition the bytes into \u003ccode\u003eBYTES_PER_CHUNK\u003c/code\u003e-byte chunks.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReturn the chunks.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis function is designed to create the chunks required to merkleize a \u003ccode\u003evalue\u003c/code\u003e that is either a basic type, a vector of basic objects or a list of basic objects. The scope of type for the \u003ccode\u003evalue\u003c/code\u003e parameter represents a function pre-condition.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003evalues\u003c/code\u003e (i.e. the plural form includes the case of a single basic type, as well as the possibility of an empty sequence in the case of a list) are firstly serialized and then if the number of resulting bytes is not a multiple of 32 then the output is right padded with zero bytes to ensure a multiple of 32 bytes.\u003c/p\u003e\n\u003cp\u003eNote that if we are dealing with an empty list then its serialized form will be zero bytes. Because zero is a multiple of 32 in this case no padding is required and zero chunks will be returned by the \u003ccode\u003epack\u003c/code\u003e function. This outcome is consistent with the intention discussed within the explanation of the chunk_count function.\u003c/p\u003e\n\u003cp\u003eThe final step of the \u003ccode\u003epack\u003c/code\u003e function is to partition the serialized and padded bytes into 32 byte chunks.\u003c/p\u003e\n\u003cp\u003eThe output of the \u003ccode\u003epack\u003c/code\u003e function is therefore a series of 32 byte chunks and we can observe the following post-conditions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 \u0026#x3C;= len(pack(values))\nlen(pack(values)) == chunk_count(type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv id='pack_bits' \u003e\n\u003c/div\u003e\n\u003ch2\u003epack_bits\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epack_bits(bits)\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eGiven the bits of bitlist or bitvector, get bitfield_bytes by packing them in bytes and aligning to the start.\u003c/li\u003e\n\u003cli\u003eThe length-delimiting bit for bitlists is excluded.\u003c/li\u003e\n\u003cli\u003eThen return \u003ccode\u003epack(bitfield_bytes)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe \u003ccode\u003epack_bits\u003c/code\u003e function is analogous to the \u003ccode\u003epack\u003c/code\u003e function with the output being a series of 32 byte chunks that willget used in the merkleization process.\u003c/p\u003e\n\u003cp\u003eIn this case the input comprises the bits of a \u003ccode\u003ebitvector\u003c/code\u003e or \u003ccode\u003ebitlist\u003c/code\u003e. It can be distinguished from the \u003ccode\u003epack\u003c/code\u003e function because the bits get packed into bytes with no delimiting bit; noting that when a \u003ccode\u003ebitlist\u003c/code\u003e is serialized the bits are also packed into bytes but a delimitng bit is appended. It is therefore almost the same as the \u003ccode\u003epack\u003c/code\u003e function but in the case of a \u003ccode\u003ebitlist\u003c/code\u003e, the serialization differs to exclude the use of a delimiting bit.\u003c/p\u003e\n\u003cp\u003eThe bytes generated are referred to as \u003ccode\u003ebitfield_bytes\u003c/code\u003e and then this series of bytes (i.e. a series of \u003ccode\u003euint8\u003c/code\u003es) become the input of \u003ccode\u003epack\u003c/code\u003e to complete the generation of the chunk output. Note that as the input to \u003ccode\u003epack\u003c/code\u003e in this context is a series of uint8s, the first step of the \u003ccode\u003epack\u003c/code\u003e function, which is to serialise the values, is redundant because serialisation of a series of uint8s will leave the bytes unchanged. The main purpose of returning \u003ccode\u003epack(bitfield_bytes)\u003c/code\u003e is to ensure that a multiple of 32 bytes is generated, using padding if needed, and then that these bytes are partitioned into the 32 byte chunks that form the ultimate output.\u003c/p\u003e\n\u003cp\u003eThe pre-condition of the \u003ccode\u003epack_bits\u003c/code\u003e function is thus that the bits are the bits of a \u003ccode\u003ebitvector\u003c/code\u003e or \u003ccode\u003ebitlist\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe post-conditions of the \u003ccode\u003epack_bits\u003c/code\u003e are the same as for the \u003ccode\u003epack\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 \u0026#x3C;= len(pack(values))\nlen(pack(values)) == chunk_count(type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv id='next_pow_of_two' \u003e\n\u003c/div\u003e\n\u003ch2\u003enext_pow_of_two\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enext_pow_of_two(i)\u003c/code\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eGet the next power of 2 of i, if not already a power of 2, with 0 mapping to 1.\n\u003cul\u003e\n\u003cli\u003eExamples: 0-\u003e1, 1-\u003e1, 2-\u003e2, 3-\u003e4, 4-\u003e4, 6-\u003e8, 9-\u003e16\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe next_pow_of_two function is a helper function for the merkleize function and is used to ensure that the number of leaves being merkleised is a power of 2.\u003c/p\u003e\n\u003cp\u003eA relatively straight forward mathematical helper function it is important to make sure that an input of zero maps to an output of 1.\u003c/p\u003e\n\u003cp\u003eHence the next_pow_of_two(i) function has the following pre-condition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 \u0026#x3C;= i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand the following post-conditions and properties:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1 \u0026#x3C;= next_pow_of_two(i)\nnext_pow_of_two(i) == next_pow_of_two(next_pow_of_two(i))\nis_power2(next_pow_of_two(i)) == true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv id='merkleize' \u003e\n\u003c/div\u003e\n\u003ch2\u003emerkleize\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emerkleize(chunks, limit=None)\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eGiven ordered BYTES_PER_CHUNK-byte chunks, merkleize the chunks, and return the root:\u003c/li\u003e\n\u003cli\u003eThe merkleization depends on the effective input, which must be padded/limited:\n\u003cul\u003e\n\u003cli\u003eif no limit: pad the chunks with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency).\u003c/li\u003e\n\u003cli\u003eif limit \u003e= len(chunks), pad the chunks with zeroed chunks to next_pow_of_two(limit) (virtually for memory efficiency).\u003c/li\u003e\n\u003cli\u003eif limit \u0026#x3C; len(chunks): do not merkleize, input exceeds limit. Raise an error instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThen, merkleize the chunks (empty input is padded to 1 zero chunk):\n\u003cul\u003e\n\u003cli\u003eIf 1 chunk: the root is the chunk itself.\u003c/li\u003e\n\u003cli\u003eIf \u003e 1 chunks: merkleize as binary tree.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe merkleize function takes a series of 32 byte chunks and a limit parameter.\u003c/p\u003e\n\u003cp\u003eThe chunks are used to form the leaves of a binary merkle tree and the function returns the root of that tree. Note that len(chunks) \u003e= 0 and hence as the chunks will form the leaves of the binary tree, chunk padding may need to be implemented to ensure that the number of leaves is a power of 2. Which power of 2 depends on the limit parameter. If there is no limit then we simply pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). If limit \u003e= len(chunks) then we pad with zeroed chunks to next_pow_of_two(len(chunks)) (virtually for memory efficiency). And if neither of these cases apply then we have a situation where something has gone wrong and the limit \u0026#x3C; len(chunks); in which case an error should be raised.\u003c/p\u003e\n\u003cp\u003eThe limit parameter has a default value of None but is generally set to chunk_count(type) where the value being processed is a variable length type such as a list or a bitlist. The use of something other than the default is to ensure that sufficient leaves are created to allow for the maximum length of that type, regardless of its current length. I say generally in the context of it being used for variable length types because limit=chunk_count(type) also appears for a bitvector; though in this case the use of the limit is redundant because a bitvector is a fixed length type and so that is no need for the provision of additional leaves; it can be seen that len(chunks) == chunk_count(type).\u003c/p\u003e\n\u003cp\u003eAt this point in the processing the number of chunks, i.e. leaves, is a power of 2 and we are ready to create the binary merkle tree. Because of the chunk padding rule we should note that there will be a minimum of 1 chunk. For example, even if zero chunks were sent into the merkleize function (e.g. as in the case of a list[B,0]) because next_pow_of_two(0) == 1 we will have 1 chunk after padding. Hence it should be noted that the second step of this function, namely Then, merkleize the chunks (empty input is padded to 1 zero chunk) includes some redundancy as empty input can not occur at this stage in the processing.\u003c/p\u003e\n\u003cp\u003eThis second step completes the processing: if we have 1 chunk then that is the root and can be returned, if we have more than 1 chunk then we implement merkelization as a binary tree.\u003c/p\u003e\n\u003cdiv id='mix_in_length' \u003e\n\u003c/div\u003e\n\u003ch2\u003emix_in_length\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emix_in_length\u003c/code\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eGiven a Merkle root \u003ccode\u003eroot\u003c/code\u003e and a length \u003ccode\u003elength\u003c/code\u003e (\u003ccode\u003euint256\u003c/code\u003e little-endian serialization) return \u003ccode\u003ehash(root + length)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis function is used for variable length types i.e. where the length of the value may be less than the maximum specified. The maximum is encoded into the binary merkle tree be the provision of sufficient leaves to store a value of this maximum length, however the actual length must also be represented and is done so through the \u003ccode\u003emix_in_length\u003c/code\u003e function. The merkle root generated from the merkleize function is concatenated with the actual length (i.e. where length is represented as a \u003ccode\u003euint256\u003c/code\u003e using little-endian serialization) and then hashed.\u003c/p\u003e\n\u003cdiv id='mix_in_type' \u003e\n\u003c/div\u003e\n\u003ch2\u003emix_in_type\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emix_in_type\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eGiven a Merkle root \u003ccode\u003eroot\u003c/code\u003e and a type_index \u003ccode\u003etype_index\u003c/code\u003e (\u003ccode\u003euint256\u003c/code\u003e little-endian serialization) return \u003ccode\u003ehash(root + type_index)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThis function is used for Union types\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n","title":"Merkleize Helper Functions","toc":["merkleize_helper_function","size_of","chunk_count","pack","pack_bits","next_pow_of_two","merkleize","mix_in_length","mix_in_type"],"prev":"Merkleize","next":"hash_tree_root"}},"__N_SSG":true},"page":"/overview/[id]","query":{"id":"merkleize_helper_functions"},"buildId":"Kw_AmIFQWArU5rLrz-lTh","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-092815d009f02b961512.js" async=""></script><script src="/_next/static/chunks/framework-5ca6b2fc774362eae352.js" async=""></script><script src="/_next/static/chunks/679-5da5ce082708612ab660.js" async=""></script><script src="/_next/static/chunks/778-f7da0898f16776c961fa.js" async=""></script><script src="/_next/static/chunks/main-b585fbee1813a2c23693.js" async=""></script><script src="/_next/static/chunks/723-7930b78c5f6cd3b643bb.js" async=""></script><script src="/_next/static/chunks/168-cab4f03cc2887b280c77.js" async=""></script><script src="/_next/static/chunks/549-f4b5e9dc3df62febb2ea.js" async=""></script><script src="/_next/static/chunks/pages/_app-239eacba429f2e007d2e.js" async=""></script><script src="/_next/static/chunks/986-f8942b1674516fcd3903.js" async=""></script><script src="/_next/static/chunks/pages/overview/%5Bid%5D-10591d769e17fd787eaf.js" async=""></script><script src="/_next/static/Kw_AmIFQWArU5rLrz-lTh/_buildManifest.js" async=""></script><script src="/_next/static/Kw_AmIFQWArU5rLrz-lTh/_ssgManifest.js" async=""></script></body></html>