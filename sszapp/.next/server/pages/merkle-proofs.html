<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous"/><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap" rel="stylesheet"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f17e70393e9af92814da.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f17e70393e9af92814da.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d42eeef79d3c09b203aa.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d42eeef79d3c09b203aa.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-559e40f4b11d93f1c328.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" as="script"/><link rel="preload" href="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" as="script"/><link rel="preload" href="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" as="script"/><link rel="preload" href="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" as="script"/><link rel="preload" href="/_next/static/chunks/4ca0644575325c63f4ab54dad24106eb862ccbd1.618d914d962df2ef8640.js" as="script"/><link rel="preload" href="/_next/static/chunks/2083ef1ea3eedc242b506d7ed25b5ecd6d7fa82f.a5b0c5535af5be785794.js" as="script"/><link rel="preload" href="/_next/static/chunks/419e82faf7791061c22b63d9065c9dd0ec8d6acb.a8b34b88149844321c86.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/merkle-proofs-2cb0e32570f1bbed0254.js" as="script"/></head><body><div id="__next"><style data-emotion="css-global 18c4non">html,body{padding:3rem 1rem;margin:0;min-height:100%;background-color:black;color:gray;font-family:Roboto,Helvetica,Arial,sans-serif;font-size:24px;}a{color:rgb(150,150,150);-webkit-text-decoration:none;text-decoration:none;}code{color:white;}section{padding:1rem;}h1{color:white;}</style><div class="Layout" style="display:flex;flex-direction:column;height:100%;width:100%"><div class="d-flex"><div class="row fixed-top "><div class="col"><div class="row"><div class="col-md-12"><nav class="navbar navbar-expand-lg navbar-dark bg-dark" collapseonselect="true" expand="lg" bg="dark" variant="dark"><div class="container-fluid"><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavDropdown"><a class="navbar-brand" href="./">SSZ</a><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" href="#Home">Home</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Overview" aria-expanded="false">Overview</a><ul class="dropdown-menu" aria-labelledby="Overview"><li><a class="dropdown-item" href="#"> <!-- -->Types</a></li><li><a class="dropdown-item" href="#"> <!-- -->Representaion</a></li><li><a class="dropdown-item" href="#"> <!-- -->Partials</a></li><li><a class="dropdown-item" href="#"> <!-- -->Navigation</a></li><li><a class="dropdown-item" href="#"> <!-- -->Merkleization</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Documentation" aria-expanded="false">Documentation</a><ul class="dropdown-menu" aria-labelledby="Documentation"><li><a class="dropdown-item" href="#"> <!-- -->Specs</a></li><li><a class="dropdown-item" href="#"> <!-- -->Wiki</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Implementations" aria-expanded="false">Implementations</a><ul class="dropdown-menu" aria-labelledby="Implementations"><li><a class="dropdown-item" href="#"> <!-- -->Python</a></li><li><a class="dropdown-item" href="#"> <!-- -->TypeScript</a></li><li><a class="dropdown-item" href="#"> <!-- -->Go</a></li><li><a class="dropdown-item" href="#"> <!-- -->Dafny</a></li><li><a class="dropdown-item" href="#"> <!-- -->Java</a></li><li><a class="dropdown-item" href="#"> <!-- -->Nim</a></li><li><a class="dropdown-item" href="#"> <!-- -->C#</a></li><li><a class="dropdown-item" href="#"> <!-- -->Zig</a></li><li><a class="dropdown-item" href="#"> <!-- -->Rust</a></li><li><a class="dropdown-item" href="#"> <!-- -->Swift</a></li></ul></li></ul></div></div></nav></div></div></div></div><div class="Content " style="flex:1;display:flex;flex-direction:column"><div class="row position-relative"><div class="col-2 justify-content-start position-fixed top-10 start-0"><nav class="nav align-items-stretch"><div><div class="nav flex-column" id="navbarSupportedContent"><div class="row justify-content-center">Site Map</div><div class="row "><div class="d-flex flex-column navbar-nav navbar-nav-scroll NavBar_nonavbar__mWkf4" style="scrollbar-width:0"><ul><div class="d-flex flex-row"><li class="nav-link" href="#">Home<!-- -->  </li></div><div class="d-flex flex-row"><li><div class="row"><a href="/merkle-proofs#">Overview</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Types<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Basic Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Complex Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Bitfields</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Unions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Representaion<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Fixed Variable Size</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Sequences</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Partials</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Navigation<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Generalized Indices</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Paths</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Summaries and Expansions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Merkleization<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Hahsing</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Chunkify</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Merkle Proofs</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Mixin</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Subtree Merkleization</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Classic Merkle Proof Backings</div></li></ul></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/merkle-proofs#">Documentation</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Specs</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Wiki</div></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/merkle-proofs#">Implementations</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Python</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">TypeScript</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Go</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Dafny</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Java</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Nim</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">C#</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Zig</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Rust</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Swift</div></li></div></ul></div></li></div></ul></div></div></div></div></nav></div><div class="col-8"></div><div class="col-2 position-fixed top-10 end-0"><div class="row"></div></div></div><div class="d-flex row position-static justify-content-center"><div class="col-8"><div class="position-relative"><div class="row position-absolute top-0 start-0"><div class="col-7"><div class="row"><h1>Merkle Proofs</h1><div><p>from Ethereum 2.0</p></div></div><div class="row"><div><section id="Helperfunctions"></section><section id="Helperfunctions"><h2>Helper functions</h2><pre><code class="language-python">def get_power_of_two_ceil(x: int) -&gt; int:
    &quot;&quot;&quot;
    Get the power of 2 for given input, or the closest higher power of 2 if the input is not a power of 2.
    Commonly used for &quot;how many nodes do I need for a bottom tree layer fitting x elements?&quot;
    Example: 0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;4, 4-&gt;4, 5-&gt;8, 6-&gt;8, 7-&gt;8, 8-&gt;8, 9-&gt;16.
    &quot;&quot;&quot;
    if x &lt;= 1:
        return 1
    elif x == 2:
        return 2
    else:
        return 2 * get_power_of_two_ceil((x + 1) // 2)</code></pre><pre><code class="language-python">def get_power_of_two_floor(x: int) -&gt; int:
    &quot;&quot;&quot;
    Get the power of 2 for given input, or the closest lower power of 2 if the input is not a power of 2.
    The zero case is a placeholder and not used for math with generalized indices.
    Commonly used for &quot;what power of two makes up the root bit of the generalized index?&quot;
    Example: 0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;2, 4-&gt;4, 5-&gt;4, 6-&gt;4, 7-&gt;4, 8-&gt;8, 9-&gt;8
    &quot;&quot;&quot;
    if x &lt;= 1:
        return 1
    if x == 2:
        return x
    else:
        return 2 * get_power_of_two_floor(x // 2)</code></pre></section></div><div><section id="GeneralizedMerkletreeindex"></section><section id="GeneralizedMerkletreeindex"><h2>Generalized Merkle tree index</h2><p>In a binary Merkle tree, we define a &quot;generalized index&quot; of a node as <code>2**depth + index</code>. Visually, this looks as follows:</p><pre><code>    1
 2     3
4 5   6 7
   ...</code></pre><p>Note that the generalized index has the convenient property that the two children of node <code>k</code> are <code>2k</code> and <code>2k+1</code>, and also that it equals the position of a node in the linear representation of the Merkle tree that&#x27;s computed by this function:</p><pre><code class="language-python">def merkle_tree(leaves: Sequence[Bytes32]) -&gt; Sequence[Bytes32]:
    &quot;&quot;&quot;
    Return an array representing the tree nodes by generalized index: 
    [0, 1, 2, 3, 4, 5, 6, 7], where each layer is a power of 2. The 0 index is ignored. The 1 index is the root.
    The result will be twice the size as the padded bottom layer for the input leaves.
    &quot;&quot;&quot;
    bottom_length = get_power_of_two_ceil(len(leaves))
    o = [Bytes32()] * bottom_length + list(leaves) + [Bytes32()] * (bottom_length - len(leaves))
    for i in range(bottom_length - 1, 0, -1):
        o[i] = hash(o[i * 2] + o[i * 2 + 1])
    return o</code></pre><p>We define a custom type <code>GeneralizedIndex</code> as a Python integer type in this document. It can be represented as a Bitvector/Bitlist object as well.
We will define Merkle proofs in terms of generalized indices.</p></section></div><div><section id="SSZobjecttoindex"></section><section id="SSZobjecttoindex"><h2>SSZ object to index</h2><p>We can describe the hash tree of any SSZ object, rooted in <code>hash_tree_root(object)</code>, as a binary Merkle tree whose depth may vary. For example, an object <code>{x: bytes32, y: List[uint64]}</code> would look as follows:</p><pre><code>     root
    /    \
   x    y_root
        /    \
y_data_root  len(y)
    / \
   /\ /\
  .......</code></pre><p>We can now define a concept of a &quot;path&quot;, a way of describing a function that takes as input an SSZ object and outputs some specific (possibly deeply nested) member. For example, <code>foo -&gt; foo.x</code> is a path, as are <code>foo -&gt; len(foo.y)</code> and <code>foo -&gt; foo.y[5].w</code>. We&#x27;ll describe paths as lists, which can have two representations. In &quot;human-readable form&quot;, they are <code>[&quot;x&quot;]</code>, <code>[&quot;y&quot;, &quot;__len__&quot;]</code> and <code>[&quot;y&quot;, 5, &quot;w&quot;]</code> respectively. In &quot;encoded form&quot;, they are lists of <code>uint64</code> values, in these cases (assuming the fields of <code>foo</code> in order are <code>x</code> then <code>y</code>, and <code>w</code> is the first field of <code>y[i]</code>) <code>[0]</code>, <code>[1, 2**64-1]</code>, <code>[1, 5, 0]</code>. We define <code>SSZVariableName</code> as the member variable name string, i.e., a path is presented as a sequence of integers and <code>SSZVariableName</code>.</p><pre><code class="language-python">def item_length(typ: SSZType) -&gt; int:
    &quot;&quot;&quot;
    Return the number of bytes in a basic type, or 32 (a full hash) for compound types.
    &quot;&quot;&quot;
    if issubclass(typ, BasicValue):
        return typ.byte_len
    else:
        return 32</code></pre><pre><code class="language-python">def get_elem_type(typ: Union[BaseBytes, BaseList, Container],
                  index_or_variable_name: Union[int, SSZVariableName]) -&gt; SSZType:
    &quot;&quot;&quot;
    Return the type of the element of an object of the given type with the given index
    or member variable name (eg. `7` for `x[7]`, `&quot;foo&quot;` for `x.foo`)
    &quot;&quot;&quot;
    return typ.get_fields()[index_or_variable_name] if issubclass(typ, Container) else typ.elem_type</code></pre><pre><code class="language-python">def chunk_count(typ: SSZType) -&gt; int:
    &quot;&quot;&quot;
    Return the number of hashes needed to represent the top-level elements in the given type
    (eg. `x.foo` or `x[7]` but not `x[7].bar` or `x.foo.baz`). In all cases except lists/vectors
    of basic types, this is simply the number of top-level elements, as each element gets one
    hash. For lists/vectors of basic types, it is often fewer because multiple basic elements
    can be packed into one 32-byte chunk.
    &quot;&quot;&quot;
    # typ.length describes the limit for list types, or the length for vector types.
    if issubclass(typ, BasicValue):
        return 1
    elif issubclass(typ, Bits):
        return (typ.length + 255) // 256
    elif issubclass(typ, Elements):
        return (typ.length * item_length(typ.elem_type) + 31) // 32
    elif issubclass(typ, Container):
        return len(typ.get_fields())
    else:
        raise Exception(f&quot;Type not supported: {typ}&quot;)</code></pre><pre><code class="language-python">def get_item_position(typ: SSZType, index_or_variable_name: Union[int, SSZVariableName]) -&gt; Tuple[int, int, int]:
    &quot;&quot;&quot;
    Return three variables:
        (i) the index of the chunk in which the given element of the item is represented;
        (ii) the starting byte position within the chunk;
        (iii) the ending byte position within the chunk.
    For example: for a 6-item list of uint64 values, index=2 will return (0, 16, 24), index=5 will return (1, 8, 16)
    &quot;&quot;&quot;
    if issubclass(typ, Elements):
        index = int(index_or_variable_name)
        start = index * item_length(typ.elem_type)
        return start // 32, start % 32, start % 32 + item_length(typ.elem_type)
    elif issubclass(typ, Container):
        variable_name = index_or_variable_name
        return typ.get_field_names().index(variable_name), 0, item_length(get_elem_type(typ, variable_name))
    else:
        raise Exception(&quot;Only lists/vectors/containers supported&quot;)</code></pre><pre><code class="language-python">def get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -&gt; GeneralizedIndex:
    &quot;&quot;&quot;
    Converts a path (eg. `[7, &quot;foo&quot;, 3]` for `x[7].foo[3]`, `[12, &quot;bar&quot;, &quot;__len__&quot;]` for
    `len(x[12].bar)`) into the generalized index representing its position in the Merkle tree.
    &quot;&quot;&quot;
    root = GeneralizedIndex(1)
    for p in path:
        assert not issubclass(typ, BasicValue)  # If we descend to a basic type, the path cannot continue further
        if p == &#x27;__len__&#x27;:
            typ = uint64
            assert issubclass(typ, (List, ByteList))
            root = GeneralizedIndex(root * 2 + 1)
        else:
            pos, _, _ = get_item_position(typ, p)
            base_index = (GeneralizedIndex(2) if issubclass(typ, (List, ByteList)) else GeneralizedIndex(1))
            root = GeneralizedIndex(root * base_index * get_power_of_two_ceil(chunk_count(typ)) + pos)
            typ = get_elem_type(typ, p)
    return root</code></pre></section></div><div><section id="Helpersforgeneralizedindices"></section><section id="Helpersforgeneralizedindices"><h3>Helpers for generalized indices</h3><p><em>Usage note: functions outside this section should manipulate generalized indices using only functions inside this section. This is to make it easier for developers to implement generalized indices with underlying representations other than bigints.</em></p></section></div><div><section id="concat_generalized_indices"></section><section id="concat_generalized_indices"><h4><code>concat_generalized_indices</code></h4><pre><code class="language-python">def concat_generalized_indices(*indices: GeneralizedIndex) -&gt; GeneralizedIndex:
    &quot;&quot;&quot;
    Given generalized indices i1 for A -&gt; B, i2 for B -&gt; C .... i_n for Y -&gt; Z, returns
    the generalized index for A -&gt; Z.
    &quot;&quot;&quot;
    o = GeneralizedIndex(1)
    for i in indices:
        o = GeneralizedIndex(o * get_power_of_two_floor(i) + (i - get_power_of_two_floor(i)))
    return o</code></pre></section></div><div><section id="get_generalized_index_length"></section><section id="get_generalized_index_length"><h4><code>get_generalized_index_length</code></h4><pre><code class="language-python">def get_generalized_index_length(index: GeneralizedIndex) -&gt; int:
    &quot;&quot;&quot;
    Return the length of a path represented by a generalized index.
    &quot;&quot;&quot;
    return int(log2(index))</code></pre></section></div><div><section id="get_generalized_index_bit"></section><section id="get_generalized_index_bit"><h4><code>get_generalized_index_bit</code></h4><pre><code class="language-python">def get_generalized_index_bit(index: GeneralizedIndex, position: int) -&gt; bool:
    &quot;&quot;&quot;
    Return the given bit of a generalized index.
    &quot;&quot;&quot;
    return (index &amp; (1 &lt;&lt; position)) &gt; 0</code></pre></section></div><div><section id="generalized_index_sibling"></section><section id="generalized_index_sibling"><h4><code>generalized_index_sibling</code></h4><pre><code class="language-python">def generalized_index_sibling(index: GeneralizedIndex) -&gt; GeneralizedIndex:
    return GeneralizedIndex(index ^ 1)</code></pre></section></div><div><section id="generalized_index_child"></section><section id="generalized_index_child"><h4><code>generalized_index_child</code></h4><pre><code class="language-python">def generalized_index_child(index: GeneralizedIndex, right_side: bool) -&gt; GeneralizedIndex:
    return GeneralizedIndex(index * 2 + right_side)</code></pre></section></div><div><section id="generalized_index_parent"></section><section id="generalized_index_parent"><h4><code>generalized_index_parent</code></h4><pre><code class="language-python">def generalized_index_parent(index: GeneralizedIndex) -&gt; GeneralizedIndex:
    return GeneralizedIndex(index // 2)</code></pre></section></div><div><section id="Merklemultiproofs"></section><section id="Merklemultiproofs"><h2>Merkle multiproofs</h2><p>We define a Merkle multiproof as a minimal subset of nodes in a Merkle tree needed to fully authenticate that a set of nodes actually are part of a Merkle tree with some specified root, at a particular set of generalized indices. For example, here is the Merkle multiproof for positions 0, 1, 6 in an 8-node Merkle tree (i.e. generalized indices 8, 9, 14):</p><pre><code>       .
   .       .
 .   *   *   .
x x . . . . x *</code></pre><p>. are unused nodes, * are used nodes, x are the values we are trying to prove. Notice how despite being a multiproof for 3 values, it requires only 3 auxiliary nodes, only one node more than would be required to prove a single value. Normally the efficiency gains are not quite that extreme, but the savings relative to individual Merkle proofs are still significant. As a rule of thumb, a multiproof for k nodes at the same level of an n-node tree has size <code>k * (n/k + log(n/k))</code>.
First, we provide a method for computing the generalized indices of the auxiliary tree nodes that a proof of a given set of generalized indices will require:</p><pre><code class="language-python">def get_branch_indices(tree_index: GeneralizedIndex) -&gt; Sequence[GeneralizedIndex]:
    &quot;&quot;&quot;
    Get the generalized indices of the sister chunks along the path from the chunk with the
    given tree index to the root.
    &quot;&quot;&quot;
    o = [generalized_index_sibling(tree_index)]
    while o[-1] &gt; 1:
        o.append(generalized_index_sibling(generalized_index_parent(o[-1])))
    return o[:-1]</code></pre><pre><code class="language-python">def get_path_indices(tree_index: GeneralizedIndex) -&gt; Sequence[GeneralizedIndex]:
    &quot;&quot;&quot;
    Get the generalized indices of the chunks along the path from the chunk with the
    given tree index to the root.
    &quot;&quot;&quot;
    o = [tree_index]
    while o[-1] &gt; 1:
        o.append(generalized_index_parent(o[-1]))
    return o[:-1]</code></pre><pre><code class="language-python">def get_helper_indices(indices: Sequence[GeneralizedIndex]) -&gt; Sequence[GeneralizedIndex]:
    &quot;&quot;&quot;
    Get the generalized indices of all &quot;extra&quot; chunks in the tree needed to prove the chunks with the given
    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the
    order of hashes in a regular single-item Merkle proof in the single-item case.
    &quot;&quot;&quot;
    all_helper_indices: Set[GeneralizedIndex] = set()
    all_path_indices: Set[GeneralizedIndex] = set()
    for index in indices:
        all_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))
        all_path_indices = all_path_indices.union(set(get_path_indices(index)))
    return sorted(all_helper_indices.difference(all_path_indices), reverse=True)</code></pre><p>Now we provide the Merkle proof verification functions. First, for single item proofs:</p><pre><code class="language-python">def calculate_merkle_root(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex) -&gt; Root:
    assert len(proof) == get_generalized_index_length(index)
    for i, h in enumerate(proof):
        if get_generalized_index_bit(index, i):
            leaf = hash(h + leaf)
        else:
            leaf = hash(leaf + h)
    return leaf</code></pre><pre><code class="language-python">def verify_merkle_proof(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex, root: Root) -&gt; bool:
    return calculate_merkle_root(leaf, proof, index) == root</code></pre><p>Now for multi-item proofs:</p><pre><code class="language-python">def calculate_multi_merkle_root(leaves: Sequence[Bytes32],
                                proof: Sequence[Bytes32],
                                indices: Sequence[GeneralizedIndex]) -&gt; Root:
    assert len(leaves) == len(indices)
    helper_indices = get_helper_indices(indices)
    assert len(proof) == len(helper_indices)
    objects = {
        **{index: node for index, node in zip(indices, leaves)},
        **{index: node for index, node in zip(helper_indices, proof)}
    }
    keys = sorted(objects.keys(), reverse=True)
    pos = 0
    while pos &lt; len(keys):
        k = keys[pos]
        if k in objects and k ^ 1 in objects and k // 2 not in objects:
            objects[GeneralizedIndex(k // 2)] = hash(
                objects[GeneralizedIndex((k | 1) ^ 1)] +
                objects[GeneralizedIndex(k | 1)]
            )
            keys.append(GeneralizedIndex(k // 2))
        pos += 1
    return objects[GeneralizedIndex(1)]</code></pre><pre><code class="language-python">def verify_merkle_multiproof(leaves: Sequence[Bytes32],
                             proof: Sequence[Bytes32],
                             indices: Sequence[GeneralizedIndex],
                             root: Root) -&gt; bool:
    return calculate_multi_merkle_root(leaves, proof, indices) == root</code></pre><p>Note that the single-item proof is a special case of a multi-item proof; a valid single-item proof verifies correctly when put into the multi-item verification function (making the natural trivial changes to input arguments, <code>index -&gt; [index]</code> and <code>leaf -&gt; [leaf]</code>). Note also that <code>calculate_merkle_root</code> and <code>calculate_multi_merkle_root</code> can be used independently to compute the new Merkle root of a proof with leaves updated.</p></section></div></div></div><div class="col-5"></div></div><div class="row position-fixed top-0 start-50"><div class="col-9"></div><div class="col-3"><div><div class="nav  flex-column TOCscroll_container__3Xcvr" id="toc"><div class="row">On This Page</div><div class="row"><div class="d-flex flex-column navbar-nav-scroll TOCscroll_nonavbar__xqG8n" style="scrollbar-width:0"><ul class=""><a href="#Helperfunctions" class="TOCscroll_Scrollspy1__ygNvR nav-link">Helperfunctions</a><a href="#GeneralizedMerkletreeindex" class="TOCscroll_Scrollspy1__ygNvR nav-link">GeneralizedMerkletreeindex</a><a href="#SSZobjecttoindex" class="TOCscroll_Scrollspy1__ygNvR nav-link">SSZobjecttoindex</a><a href="#Helpersforgeneralizedindices" class="TOCscroll_Scrollspy2__ql4PO nav-link">Helpersforgeneralizedindices</a><a href="#concat_generalized_indices" class="TOCscroll_Scrollspy3__2g8it nav-link">concat_generalized_indices</a><a href="#get_generalized_index_length" class="TOCscroll_Scrollspy3__2g8it nav-link">get_generalized_index_length</a><a href="#get_generalized_index_bit" class="TOCscroll_Scrollspy3__2g8it nav-link">get_generalized_index_bit</a><a href="#generalized_index_sibling" class="TOCscroll_Scrollspy3__2g8it nav-link">generalized_index_sibling</a><a href="#generalized_index_child" class="TOCscroll_Scrollspy3__2g8it nav-link">generalized_index_child</a><a href="#generalized_index_parent" class="TOCscroll_Scrollspy3__2g8it nav-link">generalized_index_parent</a><a href="#Merklemultiproofs" class="TOCscroll_Scrollspy1__ygNvR nav-link">Merklemultiproofs</a></ul></div></div></div></div></div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"MerkleProofsData":"# Merkle proof formats\r\n\r\n**Notice**: This document is a work-in-progress for researchers and implementers.\r\n\r\n## Table of contents\r\n\u003c!-- TOC --\u003e\r\n\u003c!-- START doctoc generated TOC please keep comment here to allow auto update --\u003e\n\u003c!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --\u003e\n\r\n\n- [Helper functions](#helper-functions)\n- [Generalized Merkle tree index](#generalized-merkle-tree-index)\n- [SSZ object to index](#ssz-object-to-index)\n  - [Helpers for generalized indices](#helpers-for-generalized-indices)\n    - [`concat_generalized_indices`](#concat_generalized_indices)\n    - [`get_generalized_index_length`](#get_generalized_index_length)\n    - [`get_generalized_index_bit`](#get_generalized_index_bit)\n    - [`generalized_index_sibling`](#generalized_index_sibling)\n    - [`generalized_index_child`](#generalized_index_child)\n    - [`generalized_index_parent`](#generalized_index_parent)\n- [Merkle multiproofs](#merkle-multiproofs)\n\n\u003c!-- END doctoc generated TOC please keep comment here to allow auto update --\u003e\n\u003c!-- /TOC --\u003e\r\n\r\n## Helper functions\r\n\r\n```python\r\ndef get_power_of_two_ceil(x: int) -\u003e int:\r\n    \"\"\"\r\n    Get the power of 2 for given input, or the closest higher power of 2 if the input is not a power of 2.\r\n    Commonly used for \"how many nodes do I need for a bottom tree layer fitting x elements?\"\r\n    Example: 0-\u003e1, 1-\u003e1, 2-\u003e2, 3-\u003e4, 4-\u003e4, 5-\u003e8, 6-\u003e8, 7-\u003e8, 8-\u003e8, 9-\u003e16.\r\n    \"\"\"\r\n    if x \u003c= 1:\r\n        return 1\r\n    elif x == 2:\r\n        return 2\r\n    else:\r\n        return 2 * get_power_of_two_ceil((x + 1) // 2)\r\n```\r\n\r\n```python\r\ndef get_power_of_two_floor(x: int) -\u003e int:\r\n    \"\"\"\r\n    Get the power of 2 for given input, or the closest lower power of 2 if the input is not a power of 2.\r\n    The zero case is a placeholder and not used for math with generalized indices.\r\n    Commonly used for \"what power of two makes up the root bit of the generalized index?\"\r\n    Example: 0-\u003e1, 1-\u003e1, 2-\u003e2, 3-\u003e2, 4-\u003e4, 5-\u003e4, 6-\u003e4, 7-\u003e4, 8-\u003e8, 9-\u003e8\r\n    \"\"\"\r\n    if x \u003c= 1:\r\n        return 1\r\n    if x == 2:\r\n        return x\r\n    else:\r\n        return 2 * get_power_of_two_floor(x // 2)\r\n```\r\n\r\n## Generalized Merkle tree index\r\n\r\nIn a binary Merkle tree, we define a \"generalized index\" of a node as `2**depth + index`. Visually, this looks as follows:\r\n\r\n```\r\n    1\r\n 2     3\r\n4 5   6 7\r\n   ...\r\n```\r\n\r\nNote that the generalized index has the convenient property that the two children of node `k` are `2k` and `2k+1`, and also that it equals the position of a node in the linear representation of the Merkle tree that's computed by this function:\r\n\r\n```python\r\ndef merkle_tree(leaves: Sequence[Bytes32]) -\u003e Sequence[Bytes32]:\r\n    \"\"\"\r\n    Return an array representing the tree nodes by generalized index: \r\n    [0, 1, 2, 3, 4, 5, 6, 7], where each layer is a power of 2. The 0 index is ignored. The 1 index is the root.\r\n    The result will be twice the size as the padded bottom layer for the input leaves.\r\n    \"\"\"\r\n    bottom_length = get_power_of_two_ceil(len(leaves))\r\n    o = [Bytes32()] * bottom_length + list(leaves) + [Bytes32()] * (bottom_length - len(leaves))\r\n    for i in range(bottom_length - 1, 0, -1):\r\n        o[i] = hash(o[i * 2] + o[i * 2 + 1])\r\n    return o\r\n```\r\n\r\nWe define a custom type `GeneralizedIndex` as a Python integer type in this document. It can be represented as a Bitvector/Bitlist object as well.\r\n\r\nWe will define Merkle proofs in terms of generalized indices.\r\n\r\n## SSZ object to index\r\n\r\nWe can describe the hash tree of any SSZ object, rooted in `hash_tree_root(object)`, as a binary Merkle tree whose depth may vary. For example, an object `{x: bytes32, y: List[uint64]}` would look as follows:\r\n\r\n```\r\n     root\r\n    /    \\\r\n   x    y_root\r\n        /    \\\r\ny_data_root  len(y)\r\n    / \\\r\n   /\\ /\\\r\n  .......\r\n```\r\n\r\nWe can now define a concept of a \"path\", a way of describing a function that takes as input an SSZ object and outputs some specific (possibly deeply nested) member. For example, `foo -\u003e foo.x` is a path, as are `foo -\u003e len(foo.y)` and `foo -\u003e foo.y[5].w`. We'll describe paths as lists, which can have two representations. In \"human-readable form\", they are `[\"x\"]`, `[\"y\", \"__len__\"]` and `[\"y\", 5, \"w\"]` respectively. In \"encoded form\", they are lists of `uint64` values, in these cases (assuming the fields of `foo` in order are `x` then `y`, and `w` is the first field of `y[i]`) `[0]`, `[1, 2**64-1]`, `[1, 5, 0]`. We define `SSZVariableName` as the member variable name string, i.e., a path is presented as a sequence of integers and `SSZVariableName`.\r\n\r\n```python\r\ndef item_length(typ: SSZType) -\u003e int:\r\n    \"\"\"\r\n    Return the number of bytes in a basic type, or 32 (a full hash) for compound types.\r\n    \"\"\"\r\n    if issubclass(typ, BasicValue):\r\n        return typ.byte_len\r\n    else:\r\n        return 32\r\n```\r\n\r\n```python\r\ndef get_elem_type(typ: Union[BaseBytes, BaseList, Container],\r\n                  index_or_variable_name: Union[int, SSZVariableName]) -\u003e SSZType:\r\n    \"\"\"\r\n    Return the type of the element of an object of the given type with the given index\r\n    or member variable name (eg. `7` for `x[7]`, `\"foo\"` for `x.foo`)\r\n    \"\"\"\r\n    return typ.get_fields()[index_or_variable_name] if issubclass(typ, Container) else typ.elem_type\r\n```\r\n\r\n```python\r\ndef chunk_count(typ: SSZType) -\u003e int:\r\n    \"\"\"\r\n    Return the number of hashes needed to represent the top-level elements in the given type\r\n    (eg. `x.foo` or `x[7]` but not `x[7].bar` or `x.foo.baz`). In all cases except lists/vectors\r\n    of basic types, this is simply the number of top-level elements, as each element gets one\r\n    hash. For lists/vectors of basic types, it is often fewer because multiple basic elements\r\n    can be packed into one 32-byte chunk.\r\n    \"\"\"\r\n    # typ.length describes the limit for list types, or the length for vector types.\r\n    if issubclass(typ, BasicValue):\r\n        return 1\r\n    elif issubclass(typ, Bits):\r\n        return (typ.length + 255) // 256\r\n    elif issubclass(typ, Elements):\r\n        return (typ.length * item_length(typ.elem_type) + 31) // 32\r\n    elif issubclass(typ, Container):\r\n        return len(typ.get_fields())\r\n    else:\r\n        raise Exception(f\"Type not supported: {typ}\")\r\n```\r\n\r\n```python\r\ndef get_item_position(typ: SSZType, index_or_variable_name: Union[int, SSZVariableName]) -\u003e Tuple[int, int, int]:\r\n    \"\"\"\r\n    Return three variables:\r\n        (i) the index of the chunk in which the given element of the item is represented;\r\n        (ii) the starting byte position within the chunk;\r\n        (iii) the ending byte position within the chunk.\r\n    For example: for a 6-item list of uint64 values, index=2 will return (0, 16, 24), index=5 will return (1, 8, 16)\r\n    \"\"\"\r\n    if issubclass(typ, Elements):\r\n        index = int(index_or_variable_name)\r\n        start = index * item_length(typ.elem_type)\r\n        return start // 32, start % 32, start % 32 + item_length(typ.elem_type)\r\n    elif issubclass(typ, Container):\r\n        variable_name = index_or_variable_name\r\n        return typ.get_field_names().index(variable_name), 0, item_length(get_elem_type(typ, variable_name))\r\n    else:\r\n        raise Exception(\"Only lists/vectors/containers supported\")\r\n```\r\n\r\n```python\r\ndef get_generalized_index(typ: SSZType, path: Sequence[Union[int, SSZVariableName]]) -\u003e GeneralizedIndex:\r\n    \"\"\"\r\n    Converts a path (eg. `[7, \"foo\", 3]` for `x[7].foo[3]`, `[12, \"bar\", \"__len__\"]` for\r\n    `len(x[12].bar)`) into the generalized index representing its position in the Merkle tree.\r\n    \"\"\"\r\n    root = GeneralizedIndex(1)\r\n    for p in path:\r\n        assert not issubclass(typ, BasicValue)  # If we descend to a basic type, the path cannot continue further\r\n        if p == '__len__':\r\n            typ = uint64\r\n            assert issubclass(typ, (List, ByteList))\r\n            root = GeneralizedIndex(root * 2 + 1)\r\n        else:\r\n            pos, _, _ = get_item_position(typ, p)\r\n            base_index = (GeneralizedIndex(2) if issubclass(typ, (List, ByteList)) else GeneralizedIndex(1))\r\n            root = GeneralizedIndex(root * base_index * get_power_of_two_ceil(chunk_count(typ)) + pos)\r\n            typ = get_elem_type(typ, p)\r\n    return root\r\n```\r\n\r\n### Helpers for generalized indices\r\n\r\n_Usage note: functions outside this section should manipulate generalized indices using only functions inside this section. This is to make it easier for developers to implement generalized indices with underlying representations other than bigints._\r\n\r\n#### `concat_generalized_indices`\r\n\r\n```python\r\ndef concat_generalized_indices(*indices: GeneralizedIndex) -\u003e GeneralizedIndex:\r\n    \"\"\"\r\n    Given generalized indices i1 for A -\u003e B, i2 for B -\u003e C .... i_n for Y -\u003e Z, returns\r\n    the generalized index for A -\u003e Z.\r\n    \"\"\"\r\n    o = GeneralizedIndex(1)\r\n    for i in indices:\r\n        o = GeneralizedIndex(o * get_power_of_two_floor(i) + (i - get_power_of_two_floor(i)))\r\n    return o\r\n```\r\n\r\n#### `get_generalized_index_length`\r\n\r\n```python\r\ndef get_generalized_index_length(index: GeneralizedIndex) -\u003e int:\r\n    \"\"\"\r\n    Return the length of a path represented by a generalized index.\r\n    \"\"\"\r\n    return int(log2(index))\r\n```\r\n\r\n#### `get_generalized_index_bit`\r\n\r\n```python\r\ndef get_generalized_index_bit(index: GeneralizedIndex, position: int) -\u003e bool:\r\n    \"\"\"\r\n    Return the given bit of a generalized index.\r\n    \"\"\"\r\n    return (index \u0026 (1 \u003c\u003c position)) \u003e 0\r\n```\r\n\r\n#### `generalized_index_sibling`\r\n\r\n```python\r\ndef generalized_index_sibling(index: GeneralizedIndex) -\u003e GeneralizedIndex:\r\n    return GeneralizedIndex(index ^ 1)\r\n```\r\n\r\n#### `generalized_index_child`\r\n\r\n```python\r\ndef generalized_index_child(index: GeneralizedIndex, right_side: bool) -\u003e GeneralizedIndex:\r\n    return GeneralizedIndex(index * 2 + right_side)\r\n```\r\n\r\n#### `generalized_index_parent`\r\n\r\n```python\r\ndef generalized_index_parent(index: GeneralizedIndex) -\u003e GeneralizedIndex:\r\n    return GeneralizedIndex(index // 2)\r\n```\r\n\r\n## Merkle multiproofs\r\n\r\nWe define a Merkle multiproof as a minimal subset of nodes in a Merkle tree needed to fully authenticate that a set of nodes actually are part of a Merkle tree with some specified root, at a particular set of generalized indices. For example, here is the Merkle multiproof for positions 0, 1, 6 in an 8-node Merkle tree (i.e. generalized indices 8, 9, 14):\r\n\r\n```\r\n       .\r\n   .       .\r\n .   *   *   .\r\nx x . . . . x *\r\n```\r\n\r\n. are unused nodes, * are used nodes, x are the values we are trying to prove. Notice how despite being a multiproof for 3 values, it requires only 3 auxiliary nodes, only one node more than would be required to prove a single value. Normally the efficiency gains are not quite that extreme, but the savings relative to individual Merkle proofs are still significant. As a rule of thumb, a multiproof for k nodes at the same level of an n-node tree has size `k * (n/k + log(n/k))`.\r\n\r\nFirst, we provide a method for computing the generalized indices of the auxiliary tree nodes that a proof of a given set of generalized indices will require:\r\n\r\n```python\r\ndef get_branch_indices(tree_index: GeneralizedIndex) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the sister chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [generalized_index_sibling(tree_index)]\r\n    while o[-1] \u003e 1:\r\n        o.append(generalized_index_sibling(generalized_index_parent(o[-1])))\r\n    return o[:-1]\r\n```\r\n\r\n```python\r\ndef get_path_indices(tree_index: GeneralizedIndex) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [tree_index]\r\n    while o[-1] \u003e 1:\r\n        o.append(generalized_index_parent(o[-1]))\r\n    return o[:-1]\r\n```\r\n\r\n```python\r\ndef get_helper_indices(indices: Sequence[GeneralizedIndex]) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of all \"extra\" chunks in the tree needed to prove the chunks with the given\r\n    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the\r\n    order of hashes in a regular single-item Merkle proof in the single-item case.\r\n    \"\"\"\r\n    all_helper_indices: Set[GeneralizedIndex] = set()\r\n    all_path_indices: Set[GeneralizedIndex] = set()\r\n    for index in indices:\r\n        all_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))\r\n        all_path_indices = all_path_indices.union(set(get_path_indices(index)))\r\n\r\n    return sorted(all_helper_indices.difference(all_path_indices), reverse=True)\r\n```\r\n\r\nNow we provide the Merkle proof verification functions. First, for single item proofs:\r\n\r\n```python\r\ndef calculate_merkle_root(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex) -\u003e Root:\r\n    assert len(proof) == get_generalized_index_length(index)\r\n    for i, h in enumerate(proof):\r\n        if get_generalized_index_bit(index, i):\r\n            leaf = hash(h + leaf)\r\n        else:\r\n            leaf = hash(leaf + h)\r\n    return leaf\r\n```\r\n\r\n```python\r\ndef verify_merkle_proof(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex, root: Root) -\u003e bool:\r\n    return calculate_merkle_root(leaf, proof, index) == root\r\n```\r\n\r\nNow for multi-item proofs:\r\n\r\n```python\r\ndef calculate_multi_merkle_root(leaves: Sequence[Bytes32],\r\n                                proof: Sequence[Bytes32],\r\n                                indices: Sequence[GeneralizedIndex]) -\u003e Root:\r\n    assert len(leaves) == len(indices)\r\n    helper_indices = get_helper_indices(indices)\r\n    assert len(proof) == len(helper_indices)\r\n    objects = {\r\n        **{index: node for index, node in zip(indices, leaves)},\r\n        **{index: node for index, node in zip(helper_indices, proof)}\r\n    }\r\n    keys = sorted(objects.keys(), reverse=True)\r\n    pos = 0\r\n    while pos \u003c len(keys):\r\n        k = keys[pos]\r\n        if k in objects and k ^ 1 in objects and k // 2 not in objects:\r\n            objects[GeneralizedIndex(k // 2)] = hash(\r\n                objects[GeneralizedIndex((k | 1) ^ 1)] +\r\n                objects[GeneralizedIndex(k | 1)]\r\n            )\r\n            keys.append(GeneralizedIndex(k // 2))\r\n        pos += 1\r\n    return objects[GeneralizedIndex(1)]\r\n```\r\n\r\n```python\r\ndef verify_merkle_multiproof(leaves: Sequence[Bytes32],\r\n                             proof: Sequence[Bytes32],\r\n                             indices: Sequence[GeneralizedIndex],\r\n                             root: Root) -\u003e bool:\r\n    return calculate_multi_merkle_root(leaves, proof, indices) == root\r\n```\r\n\r\nNote that the single-item proof is a special case of a multi-item proof; a valid single-item proof verifies correctly when put into the multi-item verification function (making the natural trivial changes to input arguments, `index -\u003e [index]` and `leaf -\u003e [leaf]`). Note also that `calculate_merkle_root` and `calculate_multi_merkle_root` can be used independently to compute the new Merkle root of a proof with leaves updated.\r\n"},"__N_SSG":true},"page":"/merkle-proofs","query":{},"buildId":"1rIoqlryeRuEXQOR6ERrX","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ad30d1320810fa304e64.js"></script><script src="/_next/static/chunks/main-559e40f4b11d93f1c328.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" async=""></script><script src="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" async=""></script><script src="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" async=""></script><script src="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" async=""></script><script src="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" async=""></script><script src="/_next/static/chunks/4ca0644575325c63f4ab54dad24106eb862ccbd1.618d914d962df2ef8640.js" async=""></script><script src="/_next/static/chunks/2083ef1ea3eedc242b506d7ed25b5ecd6d7fa82f.a5b0c5535af5be785794.js" async=""></script><script src="/_next/static/chunks/419e82faf7791061c22b63d9065c9dd0ec8d6acb.a8b34b88149844321c86.js" async=""></script><script src="/_next/static/chunks/pages/merkle-proofs-2cb0e32570f1bbed0254.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_buildManifest.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_ssgManifest.js" async=""></script></body></html>