{"pageProps":{"overviewPageData":{"id":"summaries_expansions","contentHtml":"<h2>Summaries &#x26; Expansions</h2>\n<p>Let <code>A</code> be an object derived from another object <code>B</code> by replacing some of the (possibly nested) values of <code>B</code> by their <code>hash_tree_root</code>.\r\nBecause of this substitution, <code>hash_tree_root(A) == hash_tree_root(B)</code>.</p>\n<p>We say <code>A</code> is a <strong>\"summary\"</strong> of <code>B</code>, and that <code>B</code> is an <strong>\"expansion\"</strong> of <code>A</code>. The replaced values are the <strong>\"details\"</strong> of <code>B</code> with respect to <code>A</code>.</p>\n<p>Summary instances expand to at most one instance of a given expansion:\r\nthe detail of the summary is a strict subset of that of the expansion and the difference cannot be altered without changing the summary root.</p>\n<h2>Transparency</h2>\n<p>Not all expansions may be defined ahead of time; SSZ does not limit a root to be expanded into more detail.</p>\n<p>This is a pathway for different use-cases:</p>\n<ul>\n<li>Forward-compatible hash-tree-roots: a summary definition can stay unaltered when an expansion definition is changed.</li>\n<li>Merkle proofs can navigate as far as roots can be expanded:\n<ul>\n<li>State roots, crosslink-data roots, block roots and any system root can be taken and expanded, and their data can be too.\r\nAll system data can be proven through a single merkle proof one way or another.</li>\n<li>User-level roots (e.g. beacon block graffiti) may also be given user-level expansion definitions to soft-fork in new functionality.</li>\n</ul>\n</li>\n</ul>\n<p>Warning: this is all safe when working with static expansion definitions, but pre-image attacks should be considered when working with dynamic expansions.\r\nSomeone may exploit an unexpected expansion, e.g. querying a binary path beyond the intended depth. See types below to avoid such arbitrary expansions.</p>\n<h2>As types</h2>\n<p>A summary type can be defined by taking the expansion and substituting the types of the elements to summarize with <code>Bytes32</code> to reflect their <code>hash_tree_root</code>.\r\nOr vice versa an expansion can be defined based on a summary type.</p>\n<p>Some details can also be summarized with a <code>signing_root</code>. An implementer has two options here:</p>\n<ol>\n<li>Ignore the final signature field, the root of this container in the summary type can be annotated to do this.</li>\n<li>Exclude the signature field from the expansion definition to begin with.</li>\n</ol>\n<h3>Example</h3>\n<p>In the Eth2 beacon chain, a <a href=\"https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#beaconblock\"><code>BeaconBlock</code></a>\r\nis an expansion type of <a href=\"https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#beaconblockheader\"><code>BeaconBlockHeader</code></a>.\r\nNote that a <code>BeaconBlockHeader</code> objects uniquely expands to a <code>BeaconBlock</code> object.</p>\n","title":"Summaries & Expansions","section":"Navigation"}},"__N_SSG":true}