{"pageProps":{"overviewPageData":{"id":"subtree_merkleization","contentHtml":"<h2>Subtree Merkleization</h2>\n<p>Merkleization does not have to be irregular, many types are designed to map to a stable complete tree.</p>\n<p>Subtree merkleization <code>merkle_subtree(chunks, limit=None)</code> (see <a href=\"./chunkify.md\">chunkification</a>) is defined with the following functions:</p>\n<ul>\n<li><code>next_pow_of_two(i)</code>: get the next power of 2 of <code>i</code>, if not already a power of 2, with 0 mapping to 1. Examples: <code>0->1, 1->1, 2->2, 3->4, 4->4, 6->8, 9->16</code></li>\n<li><strong><code>merkle_subtree(chunks, limit=None)</code></strong>: Given ordered chunks, merkleize the chunks, and return the root:\n<ul>\n<li>The merkleization depends on the effective input, which can be padded/limited:\n<ul>\n<li>if no limit: pad the <code>chunks</code> with zeroed chunks to <code>next_pow_of_two(len(chunks))</code> (virtually for memory efficiency).</li>\n<li>if <code>limit > len(chunks)</code>, pad the <code>chunks</code> with zeroed chunks to <code>next_pow_of_two(limit)</code> (virtually for memory efficiency).</li>\n<li>if <code>limit &#x3C; len(chunks)</code>: do not merkleize, input exceeds limit. Raise an error instead.</li>\n<li>if <code>limit == len(chunks)</code>: no-op, chunks have exactly the right length already.</li>\n</ul>\n</li>\n<li>Then, merkleize the chunks (empty input is padded to 1 zero chunk):\n<ul>\n<li>If <code>1</code> chunk: the root is the chunk itself.</li>\n<li>If <code>> 1</code> chunks: merkleize as binary tree.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>For virtual padding, two subtrees of zero-padding merkleize into a pre-computable <a href=\"./hashing.md#zero-hashes\">zero-hash</a>.</p>\n","title":"Subtree Merkleization","section":"Merkleization"}},"__N_SSG":true}