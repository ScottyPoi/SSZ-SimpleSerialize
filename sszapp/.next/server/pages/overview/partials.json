{"pageProps":{"overviewPageData":{"id":"partials","contentHtml":"<h2>Partials</h2>\n<p>One of the main uses of multi-proofs are interactions with verifiable pre-states: a merkle multi-proof verifies the data, and the data is used in a computation.</p>\n<p>With SSZ, this data can be (partially) typed, and interacted with, without dealing with the underling merkleization.</p>\n<p>This separation of the typed interface and the multi-proof enables different abstractions and use-cases:</p>\n<ul>\n<li>The multi-proof is abstracted away, merkleization and lookups may be implemented by specialized proof-backings.</li>\n<li>The verification, lookups and modifications are all just an interface feature;\r\nenvironments can decide on when and how to implement this.\n<ul>\n<li>E.g. an aggregate proof can be verified first, and subsequent individual processes can be given a scoped interface to interact with the proof data.</li>\n</ul>\n</li>\n<li>The typing interface can be extended, and new proof-backings may be introduced in the future.</li>\n</ul>\n<p>Note that the concept of <a href=\"../navigation/summaries_expansions.md\">Summaries and expansions</a> is a subset of that of partials:\r\ninstead of summarizing a type nicely at the edges of the type (i.e. summarizing fields or elements),\r\narbitrary subsets of an element can be summarised as a whole.</p>\n<p>Deciding between a partial and a summary is not difficult:</p>\n<ul>\n<li>If you need a small subset, or a very arbitrary subset, utilize the expressive flexibility of a partial.</li>\n<li>If you only need to leave out a single part, leave it out by summarizing it, and keep the type as static as possible.</li>\n</ul>\n<h2>Core functionality</h2>\n<h3><code>PartialType(base_type: SSZType, paths: Set[Path])</code></h3>\n<p>The idiomatic syntax here differs strongly per implementation, as meta-programming is not a first-class citizen in every language.\r\nThe core idea however, is to take an existing type, define the subset (e.g. a list of <a href=\"../navigation/paths.md\">ssz paths</a>) of information you need,\r\nand construct a type structure to interact with multi-proofs.</p>\n<h3><code>interface(partial_type: PartialType, proof_backing: ProofBacking) -> Partial</code></h3>\n<p>Given a partial type structure, a proof-backing can be wrapped and create a partial.</p>\n<h3><code>scope(partial_type: PartialType, paths: Set[Path]) -> PartialType</code></h3>\n<p>Since not every <code>base_type</code> can be provided in the same level of detail to create a partial-type\r\n(e.g. only select a specific set of indices of a list), additional changes to the scope should be possible to make.\r\nThe scope may may also be implemented with language-specific features (e.g. annotations, struct-tags, etc.)</p>\n<h3><code>compute_root(partial: Partial)</code></h3>\n<p>Construct the hash-tree-root (or possibly signing-root); effectively computing the root of the proof-backing. Used for verification purposes.</p>\n<p>Note that there is no signing root function; a Partial without the last Container field can be used to ignore the last field.\r\nA proof can also not back both a signing-root and hash-tree-root unless the last field would be included as witness or leaf, which is handled better by scoping the type manually.</p>\n<h2>Read-only partials</h2>\n<p>Some partials may not be meaningful to modify; in this case a proof-backing optimized for reads, and a read-only partial could be implemented.</p>\n","title":"Partials","section":"Partials"}},"__N_SSG":true}