{"pageProps":{"overviewPageData":{"id":"sequences","contentHtml":"<h2>Representation of sequences</h2>\n<p>Representation of sequences can be thought of as two parts: the fixed-size part, and the variable-size part.</p>\n<p>Fixed-size types do not have a variable part.</p>\n<p>Note that if all elements have the same type, the two parts can be specialized. However, conceptually it is all the same.</p>\n<h2>Fixed part</h2>\n<p>For each of the elements in order, if the element type is:</p>\n<ul>\n<li>fixed-size:\n<ul>\n<li>Serialize the element and append it to the fixed-size part.\n<ul>\n<li>Lists of fixed-size elements effectively concatenate all elements,\r\nthe naming of the fixed-size part as whole does not apply to the list, but to element-type.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>variable-size:\n<ul>\n<li>Append an offset to the fixed-size part, pointing to the start of the element data in the variable-size part.</li>\n<li>Serialize the element and append it to the variable size part.</li>\n</ul>\n</li>\n</ul>\n<h3>Offsets</h3>\n<p>Within the fixed-size part offsets may be encoded to locate elements in the variable-size part.</p>\n<p>Offsets are 4 bytes each, typed as <code>uint32</code>, and can range from <code>[bytelen(fixed_part), bytelen(fixed_part) + bytelen(variable_part)]</code>. I.e. the fixed-part byte length is included as part of the offset.</p>\n<p>Each offset is pointing to the start of the serialized data, the index of the first byte of the element.</p>\n<p>For each offset, it MUST hold that <code>offsets[i-1] &#x3C;= offsets[i] &#x3C;= offsets[i+1]</code>, so that elements can be read from the byte stream following the offsets in order.</p>\n<p>It also MUST hold that the first offset aligns correctly:</p>\n<ul>\n<li>In a List this means that the first offset MUST be an exact multiple of the offset size, i.e. a multiple of 4.</li>\n<li>In a Container, this means that the first offset equals the fixed-size part of the container.\n<ul>\n<li>Technically these first 4 offset bytes are unnecessary encoding, but they provide consistency between field types,\r\nto reduce complexity and increase the ability to generalize this in implementations.</li>\n</ul>\n</li>\n</ul>\n<p>Some elements in the variable-size part may be empty, this can result in:</p>\n<ul>\n<li>sequential equal offsets</li>\n<li>the last offset being equal to the end of the scope.</li>\n</ul>\n<p>There may be a dynamic number of variable-size elements all of the same type,\r\nin this case the element count can be derived from the <em>first offset</em>: <code>offset / 4</code>, as each offset matches an element and is 4 bytes.</p>\n<h2>Variable part</h2>\n<p>For variable-size elements, the elements are serialized, tightly packed, appended in order to the variable-size part.</p>\n","title":"Sequences","section":"Representation"}},"__N_SSG":true}