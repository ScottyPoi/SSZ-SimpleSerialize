{"pageProps":{"overviewPageData":{"id":"classic","contentHtml":"<h2>Classic merkle proof backing</h2>\n<p>This format is not optimal for newer multi-proof use cases, but does offer:</p>\n<ul>\n<li>Simplicity</li>\n<li>Backwards compatibility</li>\n<li>Consistency with regular single-leaf merkle proofs</li>\n</ul>\n<h2>Contents</h2>\n<ul>\n<li>Description: Generalized indices of the leaves <code>[optional]</code></li>\n<li>Leaf data: Leaf chunks <code>[optional]</code></li>\n<li>Witness data: Witness chunks</li>\n</ul>\n<p>The separation of content types, and the order of the chunks in the witness data, makes a the backing encoding compatible with a standard single leaf merkle proof. top-to-bottom branch</p>\n<h3>Description</h3>\n<p>The description of contents is kept separate from the actual witness data, and an optional part of the format:\r\nif the both the proof producing party and and proof consuming part have the same expectation of contents, there is no need to repeat it in communication.</p>\n<p>Also this fits with the existing convention for Merkle proofs where the index is separate from the proof.</p>\n<h4>Helper indices</h4>\n<p>The generalized indices of the witness data (the \"helper indices\") can be derived from those of the leaves, and are thus not encoded.\r\nThe below Python code demonstrates how this can be done:</p>\n<pre><code class=\"language-python\">def get_branch_indices(tree_index: GeneralizedIndex) -> Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the sister chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [generalized_index_sibling(tree_index)]\r\n    while o[-1] > 1:\r\n        o.append(generalized_index_sibling(generalized_index_parent(o[-1])))\r\n    return o[:-1]\n</code></pre>\n<pre><code class=\"language-python\">def get_path_indices(tree_index: GeneralizedIndex) -> Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [tree_index]\r\n    while o[-1] > 1:\r\n        o.append(generalized_index_parent(o[-1]))\r\n    return o[:-1]\n</code></pre>\n<pre><code class=\"language-python\">def get_helper_indices(indices: Sequence[GeneralizedIndex]) -> Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of all \"extra\" chunks in the tree needed to prove the chunks with the given\r\n    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the\r\n    order of hashes in a regular single-item Merkle proof in the single-item case.\r\n    \"\"\"\r\n    all_helper_indices: Set[GeneralizedIndex] = set()\r\n    all_path_indices: Set[GeneralizedIndex] = set()\r\n    for index in indices:\r\n        all_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))\r\n        all_path_indices = all_path_indices.union(set(get_path_indices(index)))\r\n\r\n    return sorted(all_helper_indices.difference(all_path_indices), reverse=True)\n</code></pre>\n<h4>Leaf Indices</h4>\n<p>The positions of the leaves are encoded in bit-alphabetical left-to-right order:</p>\n<pre><code class=\"language-python\">def split_by_root(ints, depth):\r\n    t, l, r = [], [], []\r\n    for i in ints:\r\n        if i.bit_length() &#x3C; depth:\r\n            t.append(i)\r\n        elif (i >> (i.bit_length() - depth)) % 2 == 1:\r\n            r.append(i)\r\n        else:\r\n            l.append(i)\r\n    return t, l, r\r\n\r\ndef alphasort(ints, depth=2):\r\n    if len(ints) &#x3C;= 1:\r\n        return ints\r\n    t, l, r = split_by_root(ints, depth)\r\n    return t + alphasort(l, depth+1) + alphasort(r, depth+1)\n</code></pre>\n<h5>Example</h5>\n<pre><code>Tree:\r\n   1\r\n 2   3\r\n4 5 6 7\r\n\r\n>>> alphasort([1,2,3,4,5,6,7])\r\n[1, 2, 4, 5, 3, 6, 7]\n</code></pre>\n<p>Note that not all generalized indices would be encoded, only those of the leaves the proof is targetting.\r\nThose that do get encoded will be ordered correctly for a single-pass left-to-right tree traversal for verification.</p>\n<h3>Leaf data</h3>\n<p>The leaf data is optional because in some cases the leaf data may also be known by both parties, or encoded elsewhere outside of the proof.</p>\n<p>The 32 byte chunks of data are ordered the same as the leaf indices of the description part are.</p>\n<h3>Witness data</h3>\n<p>Witness data is the essential part of the proof, and kept separate from the leaf data.</p>\n<p>Like leaf data, witness data is also sorted in bit-alphabetical left-to-right order (in respect to the generalized indices matching the chunks).</p>\n<h2>Verification</h2>\n<pre><code class=\"language-python\">def calculate_multi_merkle_root(leaves: Sequence[Bytes32],\r\n                                proof: Sequence[Bytes32],\r\n                                indices: Sequence[GeneralizedIndex]) -> Bytes32:\r\n    assert len(leaves) == len(indices)\r\n    helper_indices = get_helper_indices(indices)\r\n    assert len(proof) == len(helper_indices)\r\n    objects = {\r\n        **{index: node for index, node in zip(indices, leaves)},\r\n        **{index: node for index, node in zip(helper_indices, proof)}\r\n    }\r\n    keys = sorted(objects.keys(), reverse=True)\r\n    pos = 0\r\n    while pos &#x3C; len(keys):\r\n        k = keys[pos]\r\n        if k in objects and k ^ 1 in objects and k // 2 not in objects:\r\n            objects[GeneralizedIndex(k // 2)] = hash(\r\n                objects[GeneralizedIndex((k | 1) ^ 1)] +\r\n                objects[GeneralizedIndex(k | 1)]\r\n            )\r\n            keys.append(GeneralizedIndex(k // 2))\r\n        pos += 1\r\n    return objects[GeneralizedIndex(1)]\n</code></pre>\n<pre><code class=\"language-python\">def verify_merkle_multiproof(leaves: Sequence[Bytes32],\r\n                             proof: Sequence[Bytes32],\r\n                             indices: Sequence[GeneralizedIndex],\r\n                             root: Hash) -> bool:\r\n    return calculate_multi_merkle_root(leaves, proof, indices) == root\n</code></pre>\n<p>A challenge for the reader now, but planned as appendix to this spec,\r\nis to write an optimized single-pass stack based merkleization alternative.\r\nSince even for a multi-proof, it is not necessary to buffer too much at once.</p>\n","title":"Classic Merkle Proof Backings","section":"Merkleization"}},"__N_SSG":true}