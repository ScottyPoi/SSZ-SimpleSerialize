<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous"/><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap" rel="stylesheet"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f17e70393e9af92814da.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f17e70393e9af92814da.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-559e40f4b11d93f1c328.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" as="script"/><link rel="preload" href="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" as="script"/><link rel="preload" href="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" as="script"/><link rel="preload" href="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/overview/%5Bid%5D-c0729d659bd656a4a8e0.js" as="script"/></head><body><div id="__next"><style data-emotion="css-global 18c4non">html,body{padding:3rem 1rem;margin:0;min-height:100%;background-color:black;color:gray;font-family:Roboto,Helvetica,Arial,sans-serif;font-size:24px;}a{color:rgb(150,150,150);-webkit-text-decoration:none;text-decoration:none;}code{color:white;}section{padding:1rem;}h1{color:white;}</style><div class="Layout" style="display:flex;flex-direction:column;height:100%;width:100%"><div class="d-flex"><div class="row fixed-top "><div class="col"><div class="row"><div class="col-md-12"><nav class="navbar navbar-expand-lg navbar-dark bg-dark" collapseonselect="true" expand="lg" bg="dark" variant="dark"><div class="container-fluid"><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavDropdown"><a class="navbar-brand" href="./">SSZ</a><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" href="#Home">Home</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Overview" aria-expanded="false">Overview</a><ul class="dropdown-menu" aria-labelledby="Overview"><li><a class="dropdown-item" href="#"> <!-- -->Types</a></li><li><a class="dropdown-item" href="#"> <!-- -->Representaion</a></li><li><a class="dropdown-item" href="#"> <!-- -->Partials</a></li><li><a class="dropdown-item" href="#"> <!-- -->Navigation</a></li><li><a class="dropdown-item" href="#"> <!-- -->Merkleization</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Documentation" aria-expanded="false">Documentation</a><ul class="dropdown-menu" aria-labelledby="Documentation"><li><a class="dropdown-item" href="#"> <!-- -->Specs</a></li><li><a class="dropdown-item" href="#"> <!-- -->Wiki</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Implementations" aria-expanded="false">Implementations</a><ul class="dropdown-menu" aria-labelledby="Implementations"><li><a class="dropdown-item" href="#"> <!-- -->Python</a></li><li><a class="dropdown-item" href="#"> <!-- -->TypeScript</a></li><li><a class="dropdown-item" href="#"> <!-- -->Go</a></li><li><a class="dropdown-item" href="#"> <!-- -->Dafny</a></li><li><a class="dropdown-item" href="#"> <!-- -->Java</a></li><li><a class="dropdown-item" href="#"> <!-- -->Nim</a></li><li><a class="dropdown-item" href="#"> <!-- -->C#</a></li><li><a class="dropdown-item" href="#"> <!-- -->Zig</a></li><li><a class="dropdown-item" href="#"> <!-- -->Rust</a></li><li><a class="dropdown-item" href="#"> <!-- -->Swift</a></li></ul></li></ul></div></div></nav></div></div></div></div><div class="Content " style="flex:1;display:flex;flex-direction:column"><div class="row position-relative"><div class="col-2 justify-content-start position-fixed top-10 start-0"><nav class="nav align-items-stretch"><div><div class="nav flex-column" id="navbarSupportedContent"><div class="row justify-content-center">Site Map</div><div class="row "><div class="d-flex flex-column navbar-nav navbar-nav-scroll NavBar_nonavbar__mWkf4" style="scrollbar-width:0"><ul><div class="d-flex flex-row"><li class="nav-link" href="#">Home<!-- -->  </li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Overview</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Types<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Basic Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Complex Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Bitfields</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Unions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Representaion<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Fixed Variable Size</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Sequences</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Partials</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Navigation<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Generalized Indices</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Paths</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Summaries and Expansions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Merkleization<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Hahsing</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Chunkify</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Merkle Proofs</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Mixin</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Subtree Merkleization</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Classic Merkle Proof Backings</div></li></ul></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Documentation</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Specs</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Wiki</div></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Implementations</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Python</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">TypeScript</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Go</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Dafny</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Java</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Nim</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">C#</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Zig</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Rust</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Swift</div></li></div></ul></div></li></div></ul></div></div></div></div></nav></div><div class="col-8"></div><div class="col-2 position-fixed top-10 end-0"><div class="row"></div></div></div><div class="d-flex row position-static justify-content-center"><div class="col-8"><div class="position-relative"><div class="row fluid position-fixed bg-dark"><h1>Merkleization<!-- -->:</h1><h2>Classic Merkle Proof Backings</h2></div><div><br/><br/><br/><br/><br/><div><h2>Classic merkle proof backing</h2>
<p>This format is not optimal for newer multi-proof use cases, but does offer:</p>
<ul>
<li>Simplicity</li>
<li>Backwards compatibility</li>
<li>Consistency with regular single-leaf merkle proofs</li>
</ul>
<h2>Contents</h2>
<ul>
<li>Description: Generalized indices of the leaves <code>[optional]</code></li>
<li>Leaf data: Leaf chunks <code>[optional]</code></li>
<li>Witness data: Witness chunks</li>
</ul>
<p>The separation of content types, and the order of the chunks in the witness data, makes a the backing encoding compatible with a standard single leaf merkle proof. top-to-bottom branch</p>
<h3>Description</h3>
<p>The description of contents is kept separate from the actual witness data, and an optional part of the format:
if the both the proof producing party and and proof consuming part have the same expectation of contents, there is no need to repeat it in communication.</p>
<p>Also this fits with the existing convention for Merkle proofs where the index is separate from the proof.</p>
<h4>Helper indices</h4>
<p>The generalized indices of the witness data (the "helper indices") can be derived from those of the leaves, and are thus not encoded.
The below Python code demonstrates how this can be done:</p>
<pre><code class="language-python">def get_branch_indices(tree_index: GeneralizedIndex) -> Sequence[GeneralizedIndex]:
    """
    Get the generalized indices of the sister chunks along the path from the chunk with the
    given tree index to the root.
    """
    o = [generalized_index_sibling(tree_index)]
    while o[-1] > 1:
        o.append(generalized_index_sibling(generalized_index_parent(o[-1])))
    return o[:-1]
</code></pre>
<pre><code class="language-python">def get_path_indices(tree_index: GeneralizedIndex) -> Sequence[GeneralizedIndex]:
    """
    Get the generalized indices of the chunks along the path from the chunk with the
    given tree index to the root.
    """
    o = [tree_index]
    while o[-1] > 1:
        o.append(generalized_index_parent(o[-1]))
    return o[:-1]
</code></pre>
<pre><code class="language-python">def get_helper_indices(indices: Sequence[GeneralizedIndex]) -> Sequence[GeneralizedIndex]:
    """
    Get the generalized indices of all "extra" chunks in the tree needed to prove the chunks with the given
    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the
    order of hashes in a regular single-item Merkle proof in the single-item case.
    """
    all_helper_indices: Set[GeneralizedIndex] = set()
    all_path_indices: Set[GeneralizedIndex] = set()
    for index in indices:
        all_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))
        all_path_indices = all_path_indices.union(set(get_path_indices(index)))

    return sorted(all_helper_indices.difference(all_path_indices), reverse=True)
</code></pre>
<h4>Leaf Indices</h4>
<p>The positions of the leaves are encoded in bit-alphabetical left-to-right order:</p>
<pre><code class="language-python">def split_by_root(ints, depth):
    t, l, r = [], [], []
    for i in ints:
        if i.bit_length() &#x3C; depth:
            t.append(i)
        elif (i >> (i.bit_length() - depth)) % 2 == 1:
            r.append(i)
        else:
            l.append(i)
    return t, l, r

def alphasort(ints, depth=2):
    if len(ints) &#x3C;= 1:
        return ints
    t, l, r = split_by_root(ints, depth)
    return t + alphasort(l, depth+1) + alphasort(r, depth+1)
</code></pre>
<h5>Example</h5>
<pre><code>Tree:
   1
 2   3
4 5 6 7

>>> alphasort([1,2,3,4,5,6,7])
[1, 2, 4, 5, 3, 6, 7]
</code></pre>
<p>Note that not all generalized indices would be encoded, only those of the leaves the proof is targetting.
Those that do get encoded will be ordered correctly for a single-pass left-to-right tree traversal for verification.</p>
<h3>Leaf data</h3>
<p>The leaf data is optional because in some cases the leaf data may also be known by both parties, or encoded elsewhere outside of the proof.</p>
<p>The 32 byte chunks of data are ordered the same as the leaf indices of the description part are.</p>
<h3>Witness data</h3>
<p>Witness data is the essential part of the proof, and kept separate from the leaf data.</p>
<p>Like leaf data, witness data is also sorted in bit-alphabetical left-to-right order (in respect to the generalized indices matching the chunks).</p>
<h2>Verification</h2>
<pre><code class="language-python">def calculate_multi_merkle_root(leaves: Sequence[Bytes32],
                                proof: Sequence[Bytes32],
                                indices: Sequence[GeneralizedIndex]) -> Bytes32:
    assert len(leaves) == len(indices)
    helper_indices = get_helper_indices(indices)
    assert len(proof) == len(helper_indices)
    objects = {
        **{index: node for index, node in zip(indices, leaves)},
        **{index: node for index, node in zip(helper_indices, proof)}
    }
    keys = sorted(objects.keys(), reverse=True)
    pos = 0
    while pos &#x3C; len(keys):
        k = keys[pos]
        if k in objects and k ^ 1 in objects and k // 2 not in objects:
            objects[GeneralizedIndex(k // 2)] = hash(
                objects[GeneralizedIndex((k | 1) ^ 1)] +
                objects[GeneralizedIndex(k | 1)]
            )
            keys.append(GeneralizedIndex(k // 2))
        pos += 1
    return objects[GeneralizedIndex(1)]
</code></pre>
<pre><code class="language-python">def verify_merkle_multiproof(leaves: Sequence[Bytes32],
                             proof: Sequence[Bytes32],
                             indices: Sequence[GeneralizedIndex],
                             root: Hash) -> bool:
    return calculate_multi_merkle_root(leaves, proof, indices) == root
</code></pre>
<p>A challenge for the reader now, but planned as appendix to this spec,
is to write an optimized single-pass stack based merkleization alternative.
Since even for a multi-proof, it is not necessary to buffer too much at once.</p>
</div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"overviewPageData":{"id":"classic","contentHtml":"\u003ch2\u003eClassic merkle proof backing\u003c/h2\u003e\n\u003cp\u003eThis format is not optimal for newer multi-proof use cases, but does offer:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSimplicity\u003c/li\u003e\n\u003cli\u003eBackwards compatibility\u003c/li\u003e\n\u003cli\u003eConsistency with regular single-leaf merkle proofs\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eContents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eDescription: Generalized indices of the leaves \u003ccode\u003e[optional]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eLeaf data: Leaf chunks \u003ccode\u003e[optional]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWitness data: Witness chunks\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe separation of content types, and the order of the chunks in the witness data, makes a the backing encoding compatible with a standard single leaf merkle proof. top-to-bottom branch\u003c/p\u003e\n\u003ch3\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThe description of contents is kept separate from the actual witness data, and an optional part of the format:\r\nif the both the proof producing party and and proof consuming part have the same expectation of contents, there is no need to repeat it in communication.\u003c/p\u003e\n\u003cp\u003eAlso this fits with the existing convention for Merkle proofs where the index is separate from the proof.\u003c/p\u003e\n\u003ch4\u003eHelper indices\u003c/h4\u003e\n\u003cp\u003eThe generalized indices of the witness data (the \"helper indices\") can be derived from those of the leaves, and are thus not encoded.\r\nThe below Python code demonstrates how this can be done:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_branch_indices(tree_index: GeneralizedIndex) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the sister chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [generalized_index_sibling(tree_index)]\r\n    while o[-1] \u003e 1:\r\n        o.append(generalized_index_sibling(generalized_index_parent(o[-1])))\r\n    return o[:-1]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_path_indices(tree_index: GeneralizedIndex) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of the chunks along the path from the chunk with the\r\n    given tree index to the root.\r\n    \"\"\"\r\n    o = [tree_index]\r\n    while o[-1] \u003e 1:\r\n        o.append(generalized_index_parent(o[-1]))\r\n    return o[:-1]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_helper_indices(indices: Sequence[GeneralizedIndex]) -\u003e Sequence[GeneralizedIndex]:\r\n    \"\"\"\r\n    Get the generalized indices of all \"extra\" chunks in the tree needed to prove the chunks with the given\r\n    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the\r\n    order of hashes in a regular single-item Merkle proof in the single-item case.\r\n    \"\"\"\r\n    all_helper_indices: Set[GeneralizedIndex] = set()\r\n    all_path_indices: Set[GeneralizedIndex] = set()\r\n    for index in indices:\r\n        all_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))\r\n        all_path_indices = all_path_indices.union(set(get_path_indices(index)))\r\n\r\n    return sorted(all_helper_indices.difference(all_path_indices), reverse=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eLeaf Indices\u003c/h4\u003e\n\u003cp\u003eThe positions of the leaves are encoded in bit-alphabetical left-to-right order:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef split_by_root(ints, depth):\r\n    t, l, r = [], [], []\r\n    for i in ints:\r\n        if i.bit_length() \u0026#x3C; depth:\r\n            t.append(i)\r\n        elif (i \u003e\u003e (i.bit_length() - depth)) % 2 == 1:\r\n            r.append(i)\r\n        else:\r\n            l.append(i)\r\n    return t, l, r\r\n\r\ndef alphasort(ints, depth=2):\r\n    if len(ints) \u0026#x3C;= 1:\r\n        return ints\r\n    t, l, r = split_by_root(ints, depth)\r\n    return t + alphasort(l, depth+1) + alphasort(r, depth+1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003eExample\u003c/h5\u003e\n\u003cpre\u003e\u003ccode\u003eTree:\r\n   1\r\n 2   3\r\n4 5 6 7\r\n\r\n\u003e\u003e\u003e alphasort([1,2,3,4,5,6,7])\r\n[1, 2, 4, 5, 3, 6, 7]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that not all generalized indices would be encoded, only those of the leaves the proof is targetting.\r\nThose that do get encoded will be ordered correctly for a single-pass left-to-right tree traversal for verification.\u003c/p\u003e\n\u003ch3\u003eLeaf data\u003c/h3\u003e\n\u003cp\u003eThe leaf data is optional because in some cases the leaf data may also be known by both parties, or encoded elsewhere outside of the proof.\u003c/p\u003e\n\u003cp\u003eThe 32 byte chunks of data are ordered the same as the leaf indices of the description part are.\u003c/p\u003e\n\u003ch3\u003eWitness data\u003c/h3\u003e\n\u003cp\u003eWitness data is the essential part of the proof, and kept separate from the leaf data.\u003c/p\u003e\n\u003cp\u003eLike leaf data, witness data is also sorted in bit-alphabetical left-to-right order (in respect to the generalized indices matching the chunks).\u003c/p\u003e\n\u003ch2\u003eVerification\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef calculate_multi_merkle_root(leaves: Sequence[Bytes32],\r\n                                proof: Sequence[Bytes32],\r\n                                indices: Sequence[GeneralizedIndex]) -\u003e Bytes32:\r\n    assert len(leaves) == len(indices)\r\n    helper_indices = get_helper_indices(indices)\r\n    assert len(proof) == len(helper_indices)\r\n    objects = {\r\n        **{index: node for index, node in zip(indices, leaves)},\r\n        **{index: node for index, node in zip(helper_indices, proof)}\r\n    }\r\n    keys = sorted(objects.keys(), reverse=True)\r\n    pos = 0\r\n    while pos \u0026#x3C; len(keys):\r\n        k = keys[pos]\r\n        if k in objects and k ^ 1 in objects and k // 2 not in objects:\r\n            objects[GeneralizedIndex(k // 2)] = hash(\r\n                objects[GeneralizedIndex((k | 1) ^ 1)] +\r\n                objects[GeneralizedIndex(k | 1)]\r\n            )\r\n            keys.append(GeneralizedIndex(k // 2))\r\n        pos += 1\r\n    return objects[GeneralizedIndex(1)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef verify_merkle_multiproof(leaves: Sequence[Bytes32],\r\n                             proof: Sequence[Bytes32],\r\n                             indices: Sequence[GeneralizedIndex],\r\n                             root: Hash) -\u003e bool:\r\n    return calculate_multi_merkle_root(leaves, proof, indices) == root\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA challenge for the reader now, but planned as appendix to this spec,\r\nis to write an optimized single-pass stack based merkleization alternative.\r\nSince even for a multi-proof, it is not necessary to buffer too much at once.\u003c/p\u003e\n","title":"Classic Merkle Proof Backings","section":"Merkleization"}},"__N_SSG":true},"page":"/overview/[id]","query":{"id":"classic"},"buildId":"1rIoqlryeRuEXQOR6ERrX","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ad30d1320810fa304e64.js"></script><script src="/_next/static/chunks/main-559e40f4b11d93f1c328.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" async=""></script><script src="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" async=""></script><script src="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" async=""></script><script src="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" async=""></script><script src="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" async=""></script><script src="/_next/static/chunks/pages/overview/%5Bid%5D-c0729d659bd656a4a8e0.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_buildManifest.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_ssgManifest.js" async=""></script></body></html>