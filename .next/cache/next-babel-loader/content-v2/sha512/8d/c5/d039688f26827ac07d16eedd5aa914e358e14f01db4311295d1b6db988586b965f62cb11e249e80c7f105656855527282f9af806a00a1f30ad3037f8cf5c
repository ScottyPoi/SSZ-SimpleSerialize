{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport React from 'react';\nimport Row from 'react-bootstrap/Row';\nimport Col from 'react-bootstrap/Col';\nimport ReactMarkdown from 'react-markdown';\nimport Layout from '../components/layout';\nexport default function Introduction() {\n  return /*#__PURE__*/_jsxs(Layout, {\n    children: [/*#__PURE__*/_jsxs(Row, {\n      children: [/*#__PURE__*/_jsx(\"h2\", {\n        children: \"Design\"\n      }), /*#__PURE__*/_jsx(\"h4\", {\n        children: \"The design choices for SSZ originate from the desire for:\"\n      })]\n    }), /*#__PURE__*/_jsx(Row, {\n      children: /*#__PURE__*/_jsx(ReactMarkdown, {\n        children: \"- **Efficiency and Elegance** in proof structures with binary trees, and a design that separates opinionated sparse structures from merkleization, learning from issues in ETH 1.0. - **Consistency** in a wide range of use-cases for minimal and efficient encoding and proofs in the core of ETH 2.0, as well as the layers being built on top. - **Flexibility and Transparency** for tracing proofs through history, building shallow variants of types, or proofs to linked data such as between ETH 2.0 shards. - **Stability of proof data** for stateless light clients and smart contracts. These can count on deterministic and stable locations of merkle tree leaves of interest. - **Fast data reads** by making full deserialization optional, data can be retrieved with a very minimal amount of operations, largely pre-computable at compile time.\"\n      })\n    })]\n  });\n}","map":null,"metadata":{},"sourceType":"module"}