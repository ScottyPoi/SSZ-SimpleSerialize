<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous"/><link href="https://use.fontawesome.com/releases/v5.15.1/css/all.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap" rel="stylesheet"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f17e70393e9af92814da.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f17e70393e9af92814da.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-559e40f4b11d93f1c328.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" as="script"/><link rel="preload" href="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" as="script"/><link rel="preload" href="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" as="script"/><link rel="preload" href="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/overview/%5Bid%5D-c0729d659bd656a4a8e0.js" as="script"/></head><body><div id="__next"><style data-emotion="css-global 18c4non">html,body{padding:3rem 1rem;margin:0;min-height:100%;background-color:black;color:gray;font-family:Roboto,Helvetica,Arial,sans-serif;font-size:24px;}a{color:rgb(150,150,150);-webkit-text-decoration:none;text-decoration:none;}code{color:white;}section{padding:1rem;}h1{color:white;}</style><div class="Layout" style="display:flex;flex-direction:column;height:100%;width:100%"><div class="d-flex"><div class="row fixed-top "><div class="col"><div class="row"><div class="col-md-12"><nav class="navbar navbar-expand-lg navbar-dark bg-dark" collapseonselect="true" expand="lg" bg="dark" variant="dark"><div class="container-fluid"><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavDropdown"><a class="navbar-brand" href="./">SSZ</a><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" href="#Home">Home</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Overview" aria-expanded="false">Overview</a><ul class="dropdown-menu" aria-labelledby="Overview"><li><a class="dropdown-item" href="#"> <!-- -->Types</a></li><li><a class="dropdown-item" href="#"> <!-- -->Representaion</a></li><li><a class="dropdown-item" href="#"> <!-- -->Partials</a></li><li><a class="dropdown-item" href="#"> <!-- -->Navigation</a></li><li><a class="dropdown-item" href="#"> <!-- -->Merkleization</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Documentation" aria-expanded="false">Documentation</a><ul class="dropdown-menu" aria-labelledby="Documentation"><li><a class="dropdown-item" href="#"> <!-- -->Specs</a></li><li><a class="dropdown-item" href="#"> <!-- -->Wiki</a></li></ul></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown" id="Implementations" aria-expanded="false">Implementations</a><ul class="dropdown-menu" aria-labelledby="Implementations"><li><a class="dropdown-item" href="#"> <!-- -->Python</a></li><li><a class="dropdown-item" href="#"> <!-- -->TypeScript</a></li><li><a class="dropdown-item" href="#"> <!-- -->Go</a></li><li><a class="dropdown-item" href="#"> <!-- -->Dafny</a></li><li><a class="dropdown-item" href="#"> <!-- -->Java</a></li><li><a class="dropdown-item" href="#"> <!-- -->Nim</a></li><li><a class="dropdown-item" href="#"> <!-- -->C#</a></li><li><a class="dropdown-item" href="#"> <!-- -->Zig</a></li><li><a class="dropdown-item" href="#"> <!-- -->Rust</a></li><li><a class="dropdown-item" href="#"> <!-- -->Swift</a></li></ul></li></ul></div></div></nav></div></div></div></div><div class="Content " style="flex:1;display:flex;flex-direction:column"><div class="row position-relative"><div class="col-2 justify-content-start position-fixed top-10 start-0"><nav class="nav align-items-stretch"><div><div class="nav flex-column" id="navbarSupportedContent"><div class="row justify-content-center">Site Map</div><div class="row "><div class="d-flex flex-column navbar-nav navbar-nav-scroll NavBar_nonavbar__mWkf4" style="scrollbar-width:0"><ul><div class="d-flex flex-row"><li class="nav-link" href="#">Home<!-- -->  </li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Overview</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Types<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Basic Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Complex Types</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Bitfields</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Unions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Representaion<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Fixed Variable Size</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Sequences</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Partials</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Navigation<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Generalized Indices</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Paths</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Summaries and Expansions</div></li></ul></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE"> <!-- -->Merkleization<!-- --> </div><ul class="navbar-nav"><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Hahsing</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Chunkify</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Merkle Proofs</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Mixin</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Subtree Merkleization</div></li><li class="d-flex flex-row"><div class="NavBar_sitemap4__2Pali">Classic Merkle Proof Backings</div></li></ul></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Documentation</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Specs</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Wiki</div></li></div></ul></div></li></div><div class="d-flex flex-row"><li><div class="row"><a href="/overview/[id]#">Implementations</a><ul class="navbar-nav"><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Python</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">TypeScript</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Go</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Dafny</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Java</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Nim</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">C#</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Zig</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Rust</div></li></div><div class="d-flex flex-row"><li><div class="NavBar_sitemap3__2hayE">Swift</div></li></div></ul></div></li></div></ul></div></div></div></div></nav></div><div class="col-8"></div><div class="col-2 position-fixed top-10 end-0"><div class="row"></div></div></div><div class="d-flex row position-static justify-content-center"><div class="col-8"><div class="position-relative"><div class="row fluid position-fixed bg-dark"><h1>Merkleization<!-- -->:</h1><h2>Merkle Proofs</h2></div><div><br/><br/><br/><br/><br/><div><h2>Merkle proofs</h2>
<h2>For beginners</h2>
<p>Merkle proofs enable users to efficiently prove specific details of some data-structure that is known by a given hash.</p>
<p>The efficiency is achieved with a tree structure of hashes, with the data in the leaves of the tree.
For a proof of a set of leaves, branches to other leaves do not have to be fully encoded or hashed,
the starts of each such branch, together with the values to proof, are sufficient to reconstruct the root of the tree.
Compare the reconstructed root with the trusted root the data is known by, and the proof is complete.</p>
<h2>Accumulator</h2>
<p>Merkle trees are a type of cryptographic accumulator, and a root is a binding vector commitment to a set of contents.
I.e. the position of the contents is also committed, not just inclusion. Changing the position of any of the contents would change the Merkle root.</p>
<p>Membership of a leaf value, at a specific position, can be proven with witness data:
a set of hashes along the way to the root of the tree, taking <code>O(log(N))</code> space and computation for a proof, as opposed to <code>N</code> for providing the full data.</p>
<h2>Binary Merkle Tree</h2>
<p>The tree structure itself affects the amount of nodes, and thus the amount of hash operations, and size of the proof.</p>
<p>One of the few opinionated choices made by SSZ for Eth2 is the choice for a <strong>Binary Merkle Tree</strong>, as oposed to Merkle Patricia Trees used in Eth1.</p>
<p>Binary trees provide simplicity and efficiency:</p>
<ul>
<li>No irregular branch structures</li>
<li>Any data structure can be translated to a binary tree with minimal effort.</li>
<li>Less proof witness data in favor of a few more hash operations</li>
<li>High affinity with bitfields for navigation and description</li>
<li>Enable a wide range of other binary-tree specific optimizations</li>
</ul>
<h2>Verification</h2>
<p>Claims for leaves of data can be verified by reconstructing the root from these leaves with the help of witness data:
sibling nodes of the branches leading back to the root.</p>
<h3>Multi-proof</h3>
<p>A multi-proof is no different than a regular proof other than proving multiple leaf values at the same time.
Notice that leaf nodes that share the same subtrees also share more witness nodes, and are thus proven together more efficiently.
Sharing of witnesses in general is also more efficient than not sharing, as with individual leaf proofs.</p>
<h3>Examples</h3>
<p>The numbers used in below examples are <a href="../navigation/generalized_indices.md">generalized indices</a>, not values.
Note that the ordering of witness data is an encoding choice, defined by the <a href="#proof-backings">proof backing</a>.</p>
<h4>Classic single-leaf inclusion proofs</h4>
<pre><code>                      1
          2                       3'
    4'          5           6           7
  8    9     10'  11*    12   13     14   15
</code></pre>
<p>Leaf: <code>11</code>
Witness data: <code>10, 4, 3</code>
Proof: <code>H(H(4, H(10,11)), 3) == 1</code></p>
<h4>Multiples leaves</h4>
<p>Also called "multi-proofs".</p>
<pre><code>                      1
          2                       3
    4'          5           6           7'
  8    9     10*  11*    12'  13*    14   15
</code></pre>
<p>Leaves: <code>10,11,13</code>
Witness data: <code>4, 12, 7</code>
Proof: <code>H(H(4, H(10,11)), H(H(12,13), 7)) == 1</code></p>
<h4>Unbalanced trees</h4>
<pre><code>              1
       2              3
    4    5'        6       7'
  8' 9*        12     13'
            24'   25
                50  51
           100'101* 102*103*
</code></pre>
<p>Leaves: <code>9,101,102,103</code>
Witness data: <code>8,524,100,13,7</code>
Proof: <code>H(H(H(8,9), 5), H(H( H(24, H(H(100,101), H(102, 103))), 13), 7)) == 1</code></p>
<h2>Proof backings</h2>
<p>A "backing" is the concept of a specialized binary tree representation that implements the Merkle proof interface,
and optionally offer additional functionality like proof data lookups or modifications.</p>
<p>For an implementation, several choices can be made:</p>
<ul>
<li>Ordering of leaf nodes and witness data</li>
<li>Ordering of operations to reconstruct the root, in case of multi-proofs.</li>
<li>Inclusion of a description of the proof target leaves, or the complete proof structure.</li>
<li>Optimizations for fast reading, verification or modifications to the proof.</li>
</ul>
<p>SSZ is agnostic to this: Merkle proofs are an interface to these backings, not an enshrined choice for one approach.</p>
<h2>Interface</h2>
<p>For application level usage, describing the proof with a typed structure is recommended, see <a href="../partials">SSZ partials</a>.</p>
<p>For lower level usage, most of the complexity (and implementation freedom) is transferred to the underlying proof backing, and only a bare minimum interface is defined:</p>
<p><code>compute_root(proof_backing) -> root</code></p>
<p><code>verify(proof_backing, root) -> bool: return compute_root(proof_backing) == root</code></p>
</div></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"overviewPageData":{"id":"merkle_proofs","contentHtml":"\u003ch2\u003eMerkle proofs\u003c/h2\u003e\n\u003ch2\u003eFor beginners\u003c/h2\u003e\n\u003cp\u003eMerkle proofs enable users to efficiently prove specific details of some data-structure that is known by a given hash.\u003c/p\u003e\n\u003cp\u003eThe efficiency is achieved with a tree structure of hashes, with the data in the leaves of the tree.\r\nFor a proof of a set of leaves, branches to other leaves do not have to be fully encoded or hashed,\r\nthe starts of each such branch, together with the values to proof, are sufficient to reconstruct the root of the tree.\r\nCompare the reconstructed root with the trusted root the data is known by, and the proof is complete.\u003c/p\u003e\n\u003ch2\u003eAccumulator\u003c/h2\u003e\n\u003cp\u003eMerkle trees are a type of cryptographic accumulator, and a root is a binding vector commitment to a set of contents.\r\nI.e. the position of the contents is also committed, not just inclusion. Changing the position of any of the contents would change the Merkle root.\u003c/p\u003e\n\u003cp\u003eMembership of a leaf value, at a specific position, can be proven with witness data:\r\na set of hashes along the way to the root of the tree, taking \u003ccode\u003eO(log(N))\u003c/code\u003e space and computation for a proof, as opposed to \u003ccode\u003eN\u003c/code\u003e for providing the full data.\u003c/p\u003e\n\u003ch2\u003eBinary Merkle Tree\u003c/h2\u003e\n\u003cp\u003eThe tree structure itself affects the amount of nodes, and thus the amount of hash operations, and size of the proof.\u003c/p\u003e\n\u003cp\u003eOne of the few opinionated choices made by SSZ for Eth2 is the choice for a \u003cstrong\u003eBinary Merkle Tree\u003c/strong\u003e, as oposed to Merkle Patricia Trees used in Eth1.\u003c/p\u003e\n\u003cp\u003eBinary trees provide simplicity and efficiency:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNo irregular branch structures\u003c/li\u003e\n\u003cli\u003eAny data structure can be translated to a binary tree with minimal effort.\u003c/li\u003e\n\u003cli\u003eLess proof witness data in favor of a few more hash operations\u003c/li\u003e\n\u003cli\u003eHigh affinity with bitfields for navigation and description\u003c/li\u003e\n\u003cli\u003eEnable a wide range of other binary-tree specific optimizations\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eVerification\u003c/h2\u003e\n\u003cp\u003eClaims for leaves of data can be verified by reconstructing the root from these leaves with the help of witness data:\r\nsibling nodes of the branches leading back to the root.\u003c/p\u003e\n\u003ch3\u003eMulti-proof\u003c/h3\u003e\n\u003cp\u003eA multi-proof is no different than a regular proof other than proving multiple leaf values at the same time.\r\nNotice that leaf nodes that share the same subtrees also share more witness nodes, and are thus proven together more efficiently.\r\nSharing of witnesses in general is also more efficient than not sharing, as with individual leaf proofs.\u003c/p\u003e\n\u003ch3\u003eExamples\u003c/h3\u003e\n\u003cp\u003eThe numbers used in below examples are \u003ca href=\"../navigation/generalized_indices.md\"\u003egeneralized indices\u003c/a\u003e, not values.\r\nNote that the ordering of witness data is an encoding choice, defined by the \u003ca href=\"#proof-backings\"\u003eproof backing\u003c/a\u003e.\u003c/p\u003e\n\u003ch4\u003eClassic single-leaf inclusion proofs\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e                      1\r\n          2                       3'\r\n    4'          5           6           7\r\n  8    9     10'  11*    12   13     14   15\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLeaf: \u003ccode\u003e11\u003c/code\u003e\r\nWitness data: \u003ccode\u003e10, 4, 3\u003c/code\u003e\r\nProof: \u003ccode\u003eH(H(4, H(10,11)), 3) == 1\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003eMultiples leaves\u003c/h4\u003e\n\u003cp\u003eAlso called \"multi-proofs\".\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                      1\r\n          2                       3\r\n    4'          5           6           7'\r\n  8    9     10*  11*    12'  13*    14   15\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLeaves: \u003ccode\u003e10,11,13\u003c/code\u003e\r\nWitness data: \u003ccode\u003e4, 12, 7\u003c/code\u003e\r\nProof: \u003ccode\u003eH(H(4, H(10,11)), H(H(12,13), 7)) == 1\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003eUnbalanced trees\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e              1\r\n       2              3\r\n    4    5'        6       7'\r\n  8' 9*        12     13'\r\n            24'   25\r\n                50  51\r\n           100'101* 102*103*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLeaves: \u003ccode\u003e9,101,102,103\u003c/code\u003e\r\nWitness data: \u003ccode\u003e8,524,100,13,7\u003c/code\u003e\r\nProof: \u003ccode\u003eH(H(H(8,9), 5), H(H( H(24, H(H(100,101), H(102, 103))), 13), 7)) == 1\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003eProof backings\u003c/h2\u003e\n\u003cp\u003eA \"backing\" is the concept of a specialized binary tree representation that implements the Merkle proof interface,\r\nand optionally offer additional functionality like proof data lookups or modifications.\u003c/p\u003e\n\u003cp\u003eFor an implementation, several choices can be made:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOrdering of leaf nodes and witness data\u003c/li\u003e\n\u003cli\u003eOrdering of operations to reconstruct the root, in case of multi-proofs.\u003c/li\u003e\n\u003cli\u003eInclusion of a description of the proof target leaves, or the complete proof structure.\u003c/li\u003e\n\u003cli\u003eOptimizations for fast reading, verification or modifications to the proof.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSSZ is agnostic to this: Merkle proofs are an interface to these backings, not an enshrined choice for one approach.\u003c/p\u003e\n\u003ch2\u003eInterface\u003c/h2\u003e\n\u003cp\u003eFor application level usage, describing the proof with a typed structure is recommended, see \u003ca href=\"../partials\"\u003eSSZ partials\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor lower level usage, most of the complexity (and implementation freedom) is transferred to the underlying proof backing, and only a bare minimum interface is defined:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecompute_root(proof_backing) -\u003e root\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003everify(proof_backing, root) -\u003e bool: return compute_root(proof_backing) == root\u003c/code\u003e\u003c/p\u003e\n","title":"Merkle Proofs","section":"Merkleization"}},"__N_SSG":true},"page":"/overview/[id]","query":{"id":"merkle_proofs"},"buildId":"1rIoqlryeRuEXQOR6ERrX","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ad30d1320810fa304e64.js"></script><script src="/_next/static/chunks/main-559e40f4b11d93f1c328.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.f8bd46fc02868c500bda.js" async=""></script><script src="/_next/static/chunks/5fdcf610760714120009c40c4b2cf4f71b018be0.efb46681b7ec7fa60f89.js" async=""></script><script src="/_next/static/chunks/2fca62b02dc6d33fb50c1fe4fb323b66b5fec43e.26352c2f3d1eae2e6d70.js" async=""></script><script src="/_next/static/chunks/fb9ee39d8e03ef96d8689d22e9c23d7e1a15daf9.c483035d21d3503233b3.js" async=""></script><script src="/_next/static/chunks/pages/_app-b1740734232e9aea4955.js" async=""></script><script src="/_next/static/chunks/pages/overview/%5Bid%5D-c0729d659bd656a4a8e0.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_buildManifest.js" async=""></script><script src="/_next/static/1rIoqlryeRuEXQOR6ERrX/_ssgManifest.js" async=""></script></body></html>