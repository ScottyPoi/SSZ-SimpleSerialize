{"pageProps":{"overviewPageData":{"id":"Types","contentHtml":"<h2>Types</h2>\n<p>Types define how we interpret and interact with SSZ data.\r\nIn addition to this they provide readability, and guard users from mixing up data or processing input beyond intended limits.</p>\n<h2>Readability</h2>\n<p>Types can be aliased to more specific types, good use of type aliasing can make a data-structure much clearer.\r\nE.g. <code>BLSSignature</code> instead of <code>Vector[byte, 96]</code>.</p>\n<h2>Default values</h2>\n<p>Part of the promise of types is that data structures have defaults, avoiding <code>null</code> (a.k.a. \"the billion dollar mistake\").\r\nDefault values are recursive; elements in composite types such as containers are initialized with their respective default initializations.</p>\n<h2>Merkle proofs</h2>\n<p>Every type deterministically describes the shape of the Merkle tree representing the type:\r\nreasoning about the shape of a proof is abstracted away by the typing layer.\r\nMost types do so statically: the shape can be constructed on compile time, and navigation is stable (See <a href=\"../navigation/generalized_indices.md\">generalized indices</a>).\r\nSome types (e.g. those based on Sparse Merkle Trees) are not static, but are deterministic based the contents of the proof.</p>\n<p>Mapping a <em>valid (to the type)</em> merkle tree to that same type is bijective:</p>\n<ul>\n<li>No two different values <em>of the same type</em> can merkleize to the same root</li>\n<li>No two roots can be derived for the same value <em>of the type used for the root</em>.</li>\n</ul>\n<p>Do note that some different types may merkleize to the same root:</p>\n<ul>\n<li>Intentionally: see <a href=\"../navigation/summaries_expansions.md\">summaries and expansions</a>.</li>\n<li>Or because of different types with the same structure:\r\nTwo values <em>of different types</em> can merkleize to the same root, e.g. a <code>uint256(123)</code> and <code>uint8(123)</code> have the same root.\r\nOr more exceptionally, a <code>Container</code> with 4 <code>Bytes32</code> fields can have the same root as a <code>Vector[uint64, 16]</code>.\r\nHence, typing is essential to consuming a proof for data, and should not be chosen arbitrarily by another actor (if a different type has any meaning to the application of the proof).</li>\n</ul>\n<h2>Representation</h2>\n<p>Mapping <em>valid</em> instances of the same type to a byte sequence is bijective:</p>\n<ul>\n<li>Serialization: Any two different values <em>of the same type</em> cannot have the same representation.</li>\n<li>Deserialization: Any <em>valid</em> representation <em>of a given type</em> cannot be interpreted as two different values <em>of that same type</em>.</li>\n</ul>\n<p>Mapping <em>any</em> instance of a type to any byte sequence is <em>injective and non-surjective</em>:</p>\n<ul>\n<li>Serialization: All type instantiations can be serialized to a unique (to the type) value.</li>\n<li>Deserialization: not all byte sequences are a valid representation for a given type, because of constraints such as:\n<ul>\n<li>representation length (See <a href=\"../representation/fixed_variable_size.md\">fixed length</a>)</li>\n<li>element count (See <a href=\"./complex.md#list-limits\">list limits</a>)</li>\n<li><a href=\"../representation/sequences.md#offsets\">element offsets</a></li>\n<li>delimiters (See <a href=\"./bitfields.md#bitlist\">bitlists</a>)</li>\n<li>selectors (See <a href=\"./union.md\">union</a>)</li>\n<li>more, this is not an exhaustive list.</li>\n</ul>\n</li>\n</ul>\n","title":"Types","section":"Types"}},"__N_SSG":true}