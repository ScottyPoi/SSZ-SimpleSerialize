{"pageProps":{"overviewPageData":{"id":"generalized_indices","contentHtml":"<h2>Generalized Merkle tree index</h2>\n<p>The hash-tree-root of all SSZ types merkleizes the contents as a binary tree.\r\nIn such a binary tree, the path to any node from the root can be described by a bitfield.</p>\n<p>This bitfield can also be expressed as an integer, called a \"generalized index\" in SSZ.\r\nThe generalized index value for a node in a binary tree is <code>2**depth + index</code>, starting with a 1 for the root.\r\nVisually, this looks as follows:</p>\n<pre><code>    1\r\n 2     3\r\n4 5   6 7\r\n   ...\n</code></pre>\n<p>Like the bitfield form that is extended with a <code>0</code> or <code>1</code> for each child,\r\nthe generalized index has the convenient property that the two children of node <code>k</code> are <code>2k</code> and <code>2k+1</code>.</p>\n<h2>Combination and slicing</h2>\n<p>To navigate from <code>A</code> to <code>B</code> to <code>C</code>, where <code>B</code> is in the subtree of <code>A</code> and <code>C</code> in the subtree of <code>B</code>, the generalized indices can be composed and sliced:</p>\n<p>A generalized index is composed of a leading bit <code>1</code> for the root, and the remainder navigates the path in binary tree.</p>\n<p>These navigation parts <code>AB</code> and <code>BC</code> can be concatenated to get the navigation part <code>AC</code>: <code>AB ++ BC &#x3C;-> AC</code>.\r\nAnd then a <code>1</code> is prepended again to delimit the exact length of the path and represent the root.</p>\n<h2>Flat indexing</h2>\n<p>For implementation purposes, the generalized index matches the position of a node in the linear representation of the Merkle tree, as computed by this function:</p>\n<pre><code class=\"language-python\">def merkle_tree(leaves: Sequence[Bytes32]) -> Sequence[Bytes32]:\r\n    padded_length = get_next_power_of_two(len(leaves))\r\n    o = [Bytes32()] * padded_length + list(leaves) + [Bytes32()] * (padded_length - len(leaves))\r\n    for i in range(padded_length - 1, 0, -1):\r\n        o[i] = hash(o[i * 2] + o[i * 2 + 1])\r\n    return o\n</code></pre>\n<h2>Representation</h2>\n<p>In the SSZ spec, a generalized index is represented as a custom integer type: <code>GeneralizedIndex</code> (of arbitrary bitlength).\r\nIt can be also be represented as a Bitvector/Bitlist object.</p>\n<p>Note that for bitfields, the root bit is not encoded in SSZ:</p>\n<ul>\n<li>bitlists: SSZ already naturally appends 1 to the serialized bits, to make a difference in bitlengths.</li>\n<li>bitvectors: vectors are of fixed length, and do not need the delimiting bit.</li>\n</ul>\n","title":"Generalized Indices","section":"Navigation"}},"__N_SSG":true}