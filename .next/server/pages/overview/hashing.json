{"pageProps":{"overviewPageData":{"id":"hashing","contentHtml":"<h2>Hashing</h2>\n<p>SSZ utilizes the SHA-256 hash function.</p>\n<p>The standard specification for SHA-256 can be found in <a href=\"https://csrc.nist.gov/publications/detail/fips/180/4/final\">FIPS 180-4</a>.</p>\n<h2>Hashing primitive for binary trees.</h2>\n<pre><code>H(a: bytes32, b: bytes32) -> SHA_256(a ++ b)\n</code></pre>\n<p>Where <code>++</code> is concatenation, i.e. tightly packing <code>a</code> and <code>b</code> into 64 bytes.\r\nAnd <code>SHA_256</code> is run on the standard unmodified pre-state, and returns the digest after writing and processing the above 64 bytes.</p>\n<h2>Zero-hashes</h2>\n<p>A common occurrence in merkleization in SSZ is <code>H(X, H(0, 0)), H(X, H(H(0, 0), H(0, 0))), H(X, H(H(H(...</code></p>\n<p>The right-hand side here would be costly to merkleize leaf by leaf, but is efficiently precomputed, and referred to as a \"zero hash\" of some order N, starting from 0 being a bare zeroed <code>bytes32</code>:</p>\n<pre><code>Z[0]: 000000....   # a zeroed bytes32\r\nZ[1]: H(Z[0], Z[0])\r\nZ[2]: H(Z[1], Z[1])\r\nZ[2]: H(Z[1], Z[1])\r\nZ[3]: H(Z[2], Z[2])\r\n...\n</code></pre>\n<h2>Alternatives</h2>\n<p>Other hash-functions have been considered for specific use cases, but are actively avoided for higher compatibility with other platforms, and more consistency.</p>\n<ul>\n<li>256 bits SHA-3 and Keccak were considered but dropped in favor of SHA-256 support and compatibility.</li>\n<li>\"fast-SHA256\" as described in <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0098.mediawiki\">BIP-98</a>, optimized for two 32 byte inputs. But still a draft, and even more compatibility concerns.</li>\n<li>A S[T/N]ARK-friendly hash function, the aim is to migrate in a future Eth2 deployment phase.</li>\n</ul>\n","title":"Hashing","section":"Merkleization"}},"__N_SSG":true}