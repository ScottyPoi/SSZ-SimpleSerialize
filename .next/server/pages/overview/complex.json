{"pageProps":{"overviewPageData":{"id":"complex","contentHtml":"<h2>Complex types</h2>\n<p>Complex types are types that can hold multiple values at the same time, with usage similar to that of a <code>struct</code> in popular programming languages.</p>\n<p>The complex types are all serialized like <a href=\"../representation/sequences.md\">Sequences</a>.</p>\n<p>A complex object is considered fixed size if all of the contained elements are fixed size, and type has a fixed element count (e.g. Lists cannot be fixed size).</p>\n<p>Elements can be read and written in <code>O(1)</code>, as they are indexed (using an <a href=\"../representation/sequences.md#offsets\">offsets prologue</a> if <code>T</code> is variable size).</p>\n<h2>Vector</h2>\n<p>Type: <code>Vector[T, N]</code></p>\n<p>Default value: <code>[default(T)] * N</code>, i.e. all elements set to their default value.</p>\n<p>A Vector is a sequence of elements, all of the same type <code>T</code>, and of fixed length <code>N</code>.</p>\n<p>Empty vectors (<code>N = 0</code>) are illegal types, even if the element type <code>T</code> is dynamic length.\r\nThis is to avoid fixed-length types of 0 length, which break various size assumptions in deserialization.</p>\n<h3>Representation</h3>\n<p>Serialized and deserialized like a <a href=\"../representation/sequences.md\">Sequence</a> of the <code>values</code>, all of type <code>T</code>.</p>\n<h3>Merkleization</h3>\n<p><code>root = merkle_subtree(chunkify(values))</code>, see <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a> and <a href=\"../merkleization/chunkify.md\"><code>chunkify</code></a></p>\n<h2>Lists</h2>\n<p>Type: <code>List[T, N]</code></p>\n<p>Default value: <code>[]</code>, i.e. empty list.</p>\n<p>A List is a sequence of elements, all of the same type <code>T</code>, and can be any length from <code>0</code> to <code>N</code> (inclusive).</p>\n<p>Unlike <code>Vector</code> and <code>Container</code>, a list can have a <code>N = 0</code> limit, since it is dynamic length regardless,\r\nand types containing the list can handle a 0 byte length representation of a dynamic length element.</p>\n<h3>List Limits</h3>\n<p>The maximum list length is preset as <code>N</code> and called the \"list limit\".</p>\n<p>This limit is preset for two primary reasons:</p>\n<ul>\n<li>Stable merkleization: there are no variable numbers in the hash-tree-root definition.</li>\n<li>Strong guarantees on inputs: lists should never contain more elements than their limit states it was designed for.</li>\n</ul>\n<h4>Allocation</h4>\n<p>For small list limits, the limit type information may help to optimize for a single allocation of full list capacity.\r\nHowever, list limits can be arbitrarily high as the cost for serialization and merkleization is <code>O(n)</code>:</p>\n<ul>\n<li>the limit is not padded to in serialization</li>\n<li><code>O(log(N))</code> <a href=\"../merkleization/hashing.md#zero-hashes\">zero-hashes</a> may need to be merged during merkleization.\r\nHence, lists should not be allocated to their full limit for larger numbers.</li>\n</ul>\n<h3>Representation</h3>\n<p>Serialized and deserialized like a <a href=\"../representation/sequences.md\">Sequence</a> of the <code>values</code>, all of type <code>T</code>.\r\nThe limit of the list should be enforced, to ensure that no more than <code>N</code> elements are serialized or deserialized.</p>\n<p>Note: A list is by definition variable-size, but this does not necessarily mean its elements are.</p>\n<h3>Merkleization</h3>\n<p>Note: the contents subtree (not including the length mix-in) is padded to fit the limit of the bitlist.</p>\n<p><code>root = mix_in_num(merkle_subtree(chunkify(values), limit=chunk_count(List[T, N])), length)</code>,\r\nsee <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>,\r\n<a href=\"../merkleization/chunkify.md\"><code>chunkify, chunk_count</code></a> and <a href=\"../merkleization/mixin.md\"><code>mix_in_num</code></a>.</p>\n<h2>Container</h2>\n<p>Type: <code>Container[(&#x3C;K_i>: &#x3C;T_i>)+]</code></p>\n<p>Default value: <code>Container[(&#x3C;K_i>: &#x3C;T_i>)+](default(T_i)...)</code>, i.e. all fields set to their default value.</p>\n<p>A Container is a predefined sequence of fields, each field can be defined as any type <code>T_i</code> independently from the other fields, and is identified by a unique (relative to the other fields) name <code>K_i</code>.</p>\n<p>Note that field names are not included in serialization or merkleization: a Container is not self-describing.</p>\n<p>An empty container, i.e. 0 fields, is an illegal type. Fixed-length types cannot have a 0 length serialized representation.</p>\n<h3>Representation</h3>\n<p>Serialized and deserialized like a <a href=\"../representation/sequences.md\">Sequence</a> of the <code>fields</code>, each of their own type <code>T_i</code>.</p>\n<h3>Merkleization</h3>\n<p><code>root = merkle_subtree(chunkify(fields))</code>,\r\nsee <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>, <a href=\"../merkleization/chunkify.md\"><code>chunkify</code></a>.</p>\n","title":"Complex Types","section":"Types"}},"__N_SSG":true}