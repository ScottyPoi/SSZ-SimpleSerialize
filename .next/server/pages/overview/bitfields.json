{"pageProps":{"overviewPageData":{"id":"bitfields","contentHtml":"<h2>Bitfields</h2>\n<p>Bitfields are collections of booleans, backed by sequences of bytes: a bit at sequence index <code>i</code> is put into byte <code>i // 8</code> and matches <code>1 &#x3C;&#x3C; (i % 8)</code> within that byte.</p>\n<h2>Bitfields vs Collections</h2>\n<p>Bitfields represent boolean data in a packed form, as opposed to lists or vectors of booleans that do not efficiently utilize space.</p>\n<p>E.g. the representation of a <code>Bitvector[N]</code> is 8 times smaller than a <code>Vector[boolean, N]</code>.\r\nAnd because of <a href=\"../merkleization/chunkify.md\">chunkification</a> adapting to bitfields better than boolean collections, the Merkle tree is also 8 times smaller.</p>\n<h2>Bitvector</h2>\n<p>Type: <code>Bitvector[N]</code></p>\n<p>Default value: <code>N</code> bits, all set to <code>0</code></p>\n<p>Note that a <code>Bitvector[0]</code> is an illegal type, since fixed-length types many not have 0 byte-length representations.</p>\n<h3>Representation</h3>\n<p>A fixed-length sequence of <code>N</code> bits, packed into <code>(N + 7) // 8</code> bytes.</p>\n<p>If <code>N</code> is not a multiple of 8, the remainder of bits (high end of byte) in the <em>last</em> byte in the sequence MUST be zeroed.</p>\n<h3>Merkleization</h3>\n<p><code>root = merkle_subtree(chunkify(bitvector_value))</code>,\r\nsee <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>, <a href=\"../merkleization/chunkify.md\"><code>chunkify</code></a>.</p>\n<p>Note: A bitvector is merkleized the same as serializing it, and then merkleizing it as a <code>Vector[byte, ((N + 7) // 8)]</code>.</p>\n<h2>Bitlist</h2>\n<p>Type: <code>Bitlist[N]</code></p>\n<p>Default value: <code>0</code> bits, i.e. an empty bitlist.</p>\n<p>A dynamic-length sequence, with a limit of <code>N</code> bits, packed into bytes.\r\nThe limit here reflects the limit behavior as described by <code>List</code>: it enforces input constraints, and stabilizes merkleization depth.</p>\n<h3>Representation</h3>\n<p>From the offset coding the length (in bytes) of the bitlist is known; the bitlist cannot have redundant zero bytes.\r\nAn additional <code>1</code> bit is appended so that the length in bits will also be known: \"the delimiting bit\".</p>\n<p>This delimiting <code>1</code> bit is put in what would effectively be the bitfield index <code>bit_length(bitlist_value)</code>.\r\nNote that for an empty bitlist that would be the first bit at index 0: A single zeroed byte, or empty bytes, is illegal as bitlist representation.</p>\n<p>Because of this delimiting bit, the total byte length for serialization purposes is: <code>(((N + 1) + 7) // 8) == ((N // 8) + 1)</code></p>\n<h3>Merkleization</h3>\n<p>For merkleization, the length of the bitlist is mixed in with the root, and hence the delimiting bit is not used for merkleization.\r\nSimilarly to a <code>List</code>, the subtree is padded to fit the limit of the bitlist.</p>\n<p><code>root = mix_in_num(merkle_subtree(chunkify(bitlist_value), limit=chunk_count(Bitlist[N])), bit_length(bitlist_value))</code>,\r\nsee <a href=\"../merkleization/subtree_merkleization.md\"><code>merkle_subtree</code></a>,\r\n<a href=\"../merkleization/chunkify.md\"><code>chunkify, chunk_count</code></a> and <a href=\"../merkleization/mixin.md\"><code>mix_in_num</code></a>.</p>\n","title":"Bitfields","section":"Types"}},"__N_SSG":true}