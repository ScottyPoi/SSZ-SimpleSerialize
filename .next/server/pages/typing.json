{"pageProps":{"doc":"Stage: Candidate\r\n\r\n\r\n# Types\r\n\r\nTypes define how we interpret and interact with SSZ data.\r\nIn addition to this they provide readability, and guard users from mixing up data or processing input beyond intended limits.\r\n\r\n## Readability\r\n\r\nTypes can be aliased to more specific types, good use of type aliasing can make a data-structure much clearer.\r\nE.g. `BLSSignature` instead of `Vector[byte, 96]`.\r\n\r\n## Default values\r\n\r\nPart of the promise of types is that data structures have defaults, avoiding `null` (a.k.a. \"the billion dollar mistake\").\r\nDefault values are recursive; elements in composite types such as containers are initialized with their respective default initializations.\r\n\r\n## Merkle proofs\r\n\r\nEvery type deterministically describes the shape of the Merkle tree representing the type:\r\n reasoning about the shape of a proof is abstracted away by the typing layer.\r\nMost types do so statically: the shape can be constructed on compile time, and navigation is stable (See [generalized indices](../navigation/generalized_indices.md)).\r\nSome types (e.g. those based on Sparse Merkle Trees) are not static, but are deterministic based the contents of the proof.\r\n\r\nMapping a *valid (to the type)* merkle tree to that same type is bijective:\r\n- No two different values *of the same type* can merkleize to the same root\r\n- No two roots can be derived for the same value *of the type used for the root*.\r\n\r\nDo note that some different types may merkleize to the same root:\r\n - Intentionally: see [summaries and expansions](../navigation/summaries_expansions.md).\r\n - Or because of different types with the same structure:\r\n   Two values *of different types* can merkleize to the same root, e.g. a `uint256(123)` and `uint8(123)` have the same root.\r\n   Or more exceptionally, a `Container` with 4 `Bytes32` fields can have the same root as a `Vector[uint64, 16]`.\r\n   Hence, typing is essential to consuming a proof for data, and should not be chosen arbitrarily by another actor (if a different type has any meaning to the application of the proof).\r\n\r\n## Representation\r\n\r\nMapping *valid* instances of the same type to a byte sequence is bijective:\r\n- Serialization: Any two different values *of the same type* cannot have the same representation.\r\n- Deserialization: Any *valid* representation *of a given type* cannot be interpreted as two different values *of that same type*.\r\n\r\nMapping *any* instance of a type to any byte sequence is *injective and non-surjective*:\r\n- Serialization: All type instantiations can be serialized to a unique (to the type) value.\r\n- Deserialization: not all byte sequences are a valid representation for a given type, because of constraints such as:\r\n   - representation length (See [fixed length](../representation/fixed_variable_size.md))\r\n   - element count (See [list limits](./complex.md#list-limits))\r\n   - [element offsets](../representation/sequences.md#offsets)\r\n   - delimiters (See [bitlists](./bitfields.md#bitlist))\r\n   - selectors (See [union](./union.md))\r\n   - more, this is not an exhaustive list.\r\n"},"__N_SSG":true}